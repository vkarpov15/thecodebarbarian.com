<!DOCTYPE html><html><head><script type="text/javascript">var _sf_startpt=(new Date()).getTime()
</script><title>The 80/20 Guide to Writing AngularJS Directives | www.thecodebarbarian.com</title><meta name="viewport" content="width=device-width, initial-scale=1"><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,600,700" rel="stylesheet" type="text/css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"><link href="/style/style.css" rel="stylesheet" type="text/css"><link href="/style/github.css" rel="stylesheet" type="text/css"><script href="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script><script href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script><script href="/javascript/sidebar.js" type="text/javascript"></script><meta property="og:title" content="The 80/20 Guide to Writing AngularJS Directives"><meta property="og:url" content="http://www.thecodebarbarian.com/2013/09/23//the-8020-guide-to-writing-angularjs-directives"><meta property="og:image" content="//thehospitalitycoach.net/wp-content/uploads/2011/07/80-20-Cafe-Restaurant-Rule.jpg"><meta property="og:site_name" content="The Code Barbarian"><meta property="description" content="AngularJS is blowing up right now, and with good reason. There's nothing more satisfying than using AngularJS to turn 1,000 messy lines of Backbone.js and jQuery spaghetti code into a trivial 10 lines. To put it in a broader context, you can think of AngularJS' place in the world this way: AngularJS is to jQuery as C++11 is to x86 Assembly. However, your quest to capture all the wonderful benefits of AngularJS may be hindered because the documentation is a bit difficult to wrap your mind around. In particular, many readers have told me that the documentation for directives is pretty intimidating, and a lot of experienced users still don't quite grok how to use them properly."></head><body><div class="navbar social-links hidden-sm hidden-xs"><div class="container"><ul class="nav navbar-nav navbar-right"><li><a href="http://www.twitter.com/code_barbarian">twitter</a></li><li><a href="http://www.github.com/vkarpov15">github</a></li><li><a href="http://thecodebarbarian.com/feed.xml">rss</a></li><li><a href="/recommendations">recommendations</a></li></ul></div></div><div class="navbar" id="nav"><div class="container"><div class="navbar-header"><a class="navbar-brand big-brand" href="http://thecodebarbarian.com"><img class="logo" src="/images/Barbarian_Head.png"><span class="site-name">The Code Barbarian</span></a></div><div class="navbar-right collapse navbar-collapse" id="home-nav-mobile"><ul class="nav navbar-nav"><li><a href="/tag/mongodb.html">MongoDB</a></li><li><a href="/tag/nodejs.html">NodeJS</a></li><li><a href="/tag/asyncawait.html">Async/Await</a></li><li><a href="/tag/vue.html">Vue</a></li><li class="hidden-md hidden-lg"><a href="#">@code_barbarian</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Github</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Facebook</a></li></ul></div></div></div><div class="container-fluid"><div class="col-lg-3 col-lg-offset-9 right-bar" id="desktop-right-bar"><div class="right-bar-content-slider pull-right"><div class="row recent-posts right-bar-group"><div class="col-lg-12 articles"><p class="right-bar-label">Most Popular Articles</p><ul class="list-unstyled"><li class="right-bar-li"><a href="/common-async-await-design-patterns-in-node.js.html">Common Async/Await Design Patterns in Node.js</a></li><li class="right-bar-li"><a href="/unhandled-promise-rejections-in-node.js.html">Unhandled Promise Rejections in Node.js</a></li><li class="right-bar-li"><a href="/using-async-await-with-mocha-express-and-mongoose">Using Async/Await with Mocha, Express, and Mongoose</a></li><li class="right-bar-li"><a href="/write-your-own-node-js-promise-library-from-scratch.html">Write Your Own Node.js Promise Library from Scratch</a></li><li class="right-bar-li"><a href="/80-20-guide-to-express-error-handling">The 80/20 Guide to Express Error Handling</a></li></ul></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12 books"><p class="right-bar-label">Ebooks<div><a href="http://asyncawait.net/?utm_source=thecodebarbarian&amp;utm_campaign=sidebar"><img src="/images/verticalbanner.png"></a></div><div><a href="http://es2015generators.com"><img src="https://i.imgur.com/xvGNKlr.png"><p><i>The 80/20 Guide to ES2015 Generators</i></p></a></div><div><script type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&amp;serve=C6AILKT&amp;placement=thecodebarbariancom" id="_carbonads_js"></script></div></p></div></div></div></div></div><div class="container-fluid hidden-sm hidden-md hidden-lg" id="mobile-sharing-options"><div class="row"><div class="col-lg-12"><style>#home-nav-mobile {
  float: left !important;
  margin-left: 215px !important;
}
</style><div class="post-sharing-options"><div class="row"><div class="col-xs-3 twitter-share sharing-option"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter"></i></a></div><div class="col-xs-3 facebook-share sharing-option"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook"></i></a></div><div class="col-xs-3 google-share sharing-option"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus"></i></a></div><div class="col-xs-3 comment sharing-option"><a class="social" href="#disqus_thread"><i class="fa fa-comment"></i></a></div></div></div></div></div></div><div class="post-sharing-options hidden-xs pull-left" id="desktop-sharing-options"><ul class="list-unstyled"><li class="twitter-share"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter sharing-option"></i></a></li><li class="facebook-share"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook sharing-option"></i></a></li><li class="google-share"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus sharing-option"></i></a></li></ul></div><div class="container"><div class="col-lg-9 post-text"><div class="row"><div class="title-byline-container"><h1 class="post-title">The 80/20 Guide to Writing AngularJS Directives</h1><div class="credits"><span class="byline">by Valeri Karpov</span><span class="byhandle"><a href="http://www.twitter.com/code_barbarian">@code_barbarian</a></span><span class="bydate">September 23, 2013</span></div></div></div><script type="text/javascript" src="/js/native.js"></script><div><script>
  _native.init("CK7DT53N",{
    targetClass: 'native-inline'
  });
</script>

<div class="native-inline">
  <a href="#native_link#"><span class="sponsor">Sponsor</span> #native_company# - #native_desc#</a>
</div>
</div><div class="post-body-text-container"><p>AngularJS is blowing up right now, and with good reason. There&#39;s nothing more satisfying than using AngularJS to turn 1,000 messy lines of Backbone.js and jQuery spaghetti code into a trivial 10 lines. To put it in a broader context, you can think of AngularJS&#39; place in the world this way: AngularJS is to jQuery as C++11 is to x86 Assembly. However, your quest to capture all the wonderful benefits of AngularJS may be hindered because the documentation is a bit difficult to wrap your mind around. In particular, many readers have told me that the documentation for directives is pretty intimidating, and a lot of experienced users still don&#39;t quite grok how to use them properly.</p>
<p>First of all, let&#39;s take a moment to recognize that you&#39;re almost certainly not the only one confused.  Even I sometimes have trouble distinguishing between compile and link, or figuring out how the hell <em>ngTransclude</em> works- and I&#39;ve been working with AngularJS since version 0.9.4 in late 2010. You&#39;ll find that AngularJS directives roughly follow the <a href="http://en.wikipedia.org/wiki/Pareto_distribution">Pareto Distribution</a> - 80% of the directives that you want to build will only use 20% of the features and design patterns that are available. In other words, don&#39;t worry too much about understanding every little detail of directives. Think about git- how many programmers truly understand all the internals of interactive rebasing as opposed to simply doing pull and push to Github?</p>
<p>For most of you, the reason that you&#39;re writing directives is probably pretty straightforward, such as to integrate with existing Bootstrap modules and jQuery extensions, or to DRY up your UI. In this post, I&#39;ll lay out the basic idea behind AngularJS directives, demonstrate what they do with roughly corresponding jQuery code, and provide you with enough knowledge to develop some pretty sophisticated directives.</p>
<h2 id="your-first-directive-setting-a-background-image">Your First Directive: Setting a Background Image</h2>
<p>At the highest level, a directive allows you to wire your custom UI components in to AngularJS&#39;s two-way data-binding and scoping features, allowing you to define easily reusable ways for your users to view and interact with your underlying data. By default, a directive is a function that is run on every element with a particular attribute. This function takes as parameters the associated element and the AngularJS scope that this element is in. Let&#39;s start out with an extremely simple example: setting the minimum height and width of an image while preserving its aspect ratio. There are several ways to do this, but the easiest is to make set the image as the background of a div using the following CSS:</p>
<pre><code>.fill-bg {
  background-image: url(<span class="hljs-string">'MYURLHERE'</span>);
  background-size : <span class="hljs-string">'cover'</span>;
  background-repeat : <span class="hljs-string">'no-repeat'</span>;
  background-position : <span class="hljs-string">'center center'</span>;
}</code></pre><p>Now let&#39;s say we wanted to automate this process, so that our designers don&#39;t have to write a separate CSS class for each image. We&#39;ll do this by adding an attribute called &#39;cover-background-image&#39; to some divs so our Javascript knows which image to set as the background. We can do this with jQuery or AngularJS, but lets do jQuery first. The general idea looks like this <a href="http://jsfiddle.net/vkarpov15/BQvbg/1/">(see it in action on JSFiddle)</a>:</p>
<pre><code>$(<span class="hljs-string">'div[cover-background-image]'</span>).
  each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, el</span>) </span>{
    $(element).css({
      <span class="hljs-string">'background-image'</span>: <span class="hljs-string">'url()'</span>,
      <span class="hljs-string">'background-size'</span>: <span class="hljs-string">'cover'</span>,
      <span class="hljs-string">'background-repeat'</span>: <span class="hljs-string">'no-repeat'</span>,
      <span class="hljs-string">'background-position'</span>: <span class="hljs-string">'center center'</span>
    });
  });</code></pre><p>The general process will be the same with a directive - AngularJS calls your custom directive code for each element with a given attribute. Below is the equivalent directive in AngularJS, and on <a href="http://jsfiddle.net/vkarpov15/NE9cu/">JSFiddle</a>:</p>
<pre><code><span class="hljs-keyword">var</span> m = angular.module(<span class="hljs-string">'myApp'</span>, []).
m.directive(<span class="hljs-string">'myBackgroundImage'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, element, attrs</span>) </span>{
    <span class="hljs-keyword">var</span> url = <span class="hljs-string">'url('</span> +
      attrs.myBackgroundImage + <span class="hljs-string">')'</span>;
    <span class="hljs-keyword">var</span> pos = <span class="hljs-string">'center center'</span>;
    element.css({
      <span class="hljs-string">'background-image'</span>: url,
      <span class="hljs-string">'background-size'</span>: <span class="hljs-string">'cover'</span>,
      <span class="hljs-string">'background-repeat'</span>: <span class="hljs-string">'no-repeat'</span>,
      <span class="hljs-string">'background-position'</span>: pos
    });
  };
});</code></pre><h2 id="making-the-directive-dynamic">Making The Directive Dynamic</h2>
<p>At this point some of you might be thinking, &quot;Hey, the only difference is that AngularJS requires more code!&quot; This is true for a relatively simple example like the one above. However, the real advantage to the AngularJS approach comes when you introduce two-way data-binding and the power of AngularJS scopes. Lets say that we want to introduce some carousel behavior to this image (switching the image every 5 seconds and allowing the user to navigate between images). In jQuery, supporting multiple carousels on the same page turns out to be a huge pain, because we have no easy way for mapping which images and which buttons belong to which carousel. When you try it the hard way, things end up looking a little something like this <a href="http://jsfiddle.net/vkarpov15/DDnUt/">JSFiddle</a>:</p>
<pre><code>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  $(<span class="hljs-string">'div[cover-background-image]'</span>).
    each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, el</span>) </span>{
      <span class="hljs-keyword">var</span> ctr = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">var</span> images = <span class="hljs-built_in">eval</span>(
        $(el).attr(<span class="hljs-string">'cover-background-image'</span>));
      <span class="hljs-keyword">var</span> name = $(el).attr(<span class="hljs-string">'carousel-name'</span>);
      <span class="hljs-keyword">var</span> nextImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        ctr = (ctr + <span class="hljs-number">1</span>) % images.length;
        <span class="hljs-keyword">var</span> url = <span class="hljs-string">'url('</span> + images[ctr] + <span class="hljs-string">')'</span>;
        $(el).css({
          <span class="hljs-string">'background-image'</span>: url,
          <span class="hljs-string">'background-size'</span>: <span class="hljs-string">'cover'</span>,
          <span class="hljs-string">'background-repeat'</span>: <span class="hljs-string">'no-repeat'</span>,
          <span class="hljs-string">'background-position'</span>: <span class="hljs-string">'center center'</span>
        });
      };
      <span class="hljs-keyword">var</span> previousImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        ctr = (ctr - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (ctr &amp;amp;lt; <span class="hljs-number">0</span>) {
          ctr = images.length - <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">var</span> url = <span class="hljs-string">'url('</span> + images[ctr] + <span class="hljs-string">')'</span>;
        $(el).css({
          <span class="hljs-string">'background-image'</span>: url,
          <span class="hljs-string">'background-size'</span>: <span class="hljs-string">'cover'</span>,
          <span class="hljs-string">'background-repeat'</span>: <span class="hljs-string">'no-repeat'</span>,
          <span class="hljs-string">'background-position'</span>: <span class="hljs-string">'center center'</span>
        });
      };
      $(<span class="hljs-string">"div[carousel-next='"</span> + name + <span class="hljs-string">"']"</span>).
        each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, el</span>) </span>{
          $(el).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            nextImage();
          });
        });
      $(<span class="hljs-string">"div[carousel-prev='"</span> + name + <span class="hljs-string">"']"</span>).
        each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, el</span>) </span>{
          $(el).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            previousImage();
          });
        });
      nextImage();
      <span class="hljs-keyword">var</span> nextImageTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        nextImage();
        setTimeout(nextImageTimeout, <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);
      };
      setTimeout(nextImageTimeout, <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);
    });
});</code></pre><p>As you can see, this is pretty quickly getting a bit more complex than we&#39;d like. More importantly, we&#39;ve needed to hard-code the <em>my-background-image</em> pseudo-directive with certain properties that will make our lives difficult later.</p>
<p>First of all, we require the input of an array of images to be cycled. That may be fine for this specific application, but what if we want to re-use this code for a single image with no cycling? Then we&#39;ve got a timer that&#39;s doing nothing. Furthermore, putting an array variable in &#39;my-background-image&#39; requires that the variable be visible from the scope of the jQuery code. This leads to both headaches and lots of image arrays in the global scope. Finally, lets say that we want to add additional behaviors, such as swipe handling via <a href="http://eightmedia.github.io/hammer.js/">Hammer.js</a>. It becomes difficult to configure this behavior on a per-carousel basis - what if we have some carousels that should have swipe recognition and some that shouldn&#39;t?</p>
<p>Now that we&#39;ve seen the difficulties that come with trying to make customizable and reusable UI behaviors and components, lets see how AngularJS provides us with the right framework and tools to do this task easily. Here&#39;s the first of four design patterns that you&#39;ll see frequently with AngularJS directives. With each pattern, I&#39;ll describe to you how the pattern works, and provide examples of this pattern in action both in my own JSFiddles and what others have written.</p>
<h2 id="basic-directive-design-pattern-watch-and-update">Basic Directive Design Pattern: Watch and Update</h2>
<p><em>Example: Display a cropped image using CSS and update it whenever the underlying variable changes</em></p>
<p><em>Alternative Example: <a href="https://github.com/angular-ui/bootstrap/blob/master/src/progressbar/progressbar.js">angular-ui/bootstrap&#39;s progressbar directive</a></em></p>
<p>One design pattern you&#39;ll see frequently with AngularJS directives is &quot;Watch and Update:&quot; watching a single value and updating the DOM when this value changes to reflect our internal state. Often this can be taken care of using combinations of the built-in <a href="http://docs.angularjs.org/api/ng.directive:ngClass"><code>ngClass</code></a> and <a href="http://docs.angularjs.org/api/ng.directive:ngStyle"><code>ngStyle</code></a> directives, but for more complex manipulations you may want to use your own directive to make sure your code is DRY. Our new myBackgroundImage directive will use a very simple &quot;watch and update&quot; pattern (view on <a href="http://jsfiddle.net/vkarpov15/B6kUJ/">JSFiddle</a>):</p>
<pre><code>angular.
<span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp'</span>, []).
directive(<span class="hljs-string">'myBackgroundImage'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, element, attrs</span>) </span>{
    scope.$watch(attrs.myBackgroundImage,
      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
        element.css({
          <span class="hljs-string">'background-image'</span>: <span class="hljs-string">'url('</span> + v + <span class="hljs-string">')'</span>,
          <span class="hljs-string">'background-size'</span>: <span class="hljs-string">'cover'</span>,
          <span class="hljs-string">'background-repeat'</span>: <span class="hljs-string">'no-repeat'</span>,
          <span class="hljs-string">'background-position'</span>: <span class="hljs-string">'center center'</span>
        });
      });
  };
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CarouselController</span>(<span class="hljs-params">$scope, $timeout</span>) </span>{
  $scope.images = [];
  $scope.image = <span class="hljs-string">""</span>
  $scope.index = <span class="hljs-number">0</span>;

  $scope.setImages = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">images</span>) </span>{
    $scope.images = images;
    $scope.image = images[<span class="hljs-number">0</span>];
    $scope.index = <span class="hljs-number">0</span>;
  };

  $scope.nextImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    $scope.index = ($scope.index + <span class="hljs-number">1</span>) %
      $scope.images.length;
    $scope.image = $scope.images[$scope.index];
  };

  $scope.prevImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    $scope.index = ($scope.index - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> ?
      $scope.index - <span class="hljs-number">1</span> :
      $scope.images.length - <span class="hljs-number">1</span>);
    $scope.image = $scope.images[$scope.index];
  };

  <span class="hljs-keyword">var</span> nextImageTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    $scope.nextImage();
    $timeout(nextImageTimeout, <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);
  };

  $timeout(nextImageTimeout, <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);
}</code></pre><p>With two-way data-binding, our directive changes very minimally from the previous example. Instead of taking the <code>my-background-image</code> attribute as a vanilla string, we tell AngularJS to interpret it as a variable and watch its value with a <code>scope.$watch</code> call. When the value changes, we update our CSS. We then move the carousel functionality to an AngularJS controller, so that we can reuse our directive in other non-carousel contexts. As you can see in the JSFiddle, we added an &quot;Add Image&quot; button that pushes another image to the top carousel&#39;s images collection, allowing the carousel to update automatically.</p>
<p>Most importantly, AngularJS handles scoping for us, meaning that we can reference functions within the AngularJS controller from our HTML. Imagine trying to do something similar with onclick and jQuery - we would have to get very creative with refactoring our code to take all of our user behaviors out of <code>myBackgroundImage</code>.</p>
<p>Now that we&#39;ve gotten the carousel functionality, it&#39;s simple enough to add an <code>ngSwipe</code> directive to our AngularJS module that will enable our users to navigate between images with swipes. Speaking of which:</p>
<h2 id="basic-directive-design-pattern-wiring-external-event-handlers-to-call-apply">Basic Directive Design Pattern: Wiring External Event Handlers to call <code>$apply</code></h2>
<p><em>Example: Writing a directive to wire Hammer.js swipeleft and swiperight with AngularJS</em></p>
<p><em>Alternative Example: <a href="http://jsfiddle.net/mwDQr/1/">Hooking up the Google Places Autocomplete with AngularJS</a></em></p>
<p>Another common task in writing AngularJS directives, especially when integrating with non-AngularJS libraries, is hooking up event handlers to update your AngularJS scope. Without going into too much detail about AngularJS&#39; internals, each scope has:</p>
<ol>
<li>An <code>$apply</code> function that notifies AngularJS when some event has happened that may require updating the view.</li>
<li>An <code>$eval</code> function, which does a safe eval on its parameter in the scope.</li>
</ol>
<p>When you include external event handlers, such as the <code>.on()</code> calls that many jQuery plugins support, AngularJS does not know that they exist, so your directive needs to tell AngularJS how to handle them. In our case, lets hook up a directive that will listen to Hammer.js&#39;s swipe left and swipe right events (view on <a href="http://jsfiddle.net/vkarpov15/5vajr/">JSFiddle</a> - you don&#39;t need a phone or tablet to trigger a swipe event, just drag your mouse quickly across one of the images):</p>
<pre><code>angular.
  <span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp'</span>, []).
  directive(<span class="hljs-string">'myBackgroundImage'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, element, attrs</span>) </span>{
      scope.$watch(attrs.myBackgroundImage,
        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
          <span class="hljs-keyword">var</span> url = <span class="hljs-string">'url('</span> + v + <span class="hljs-string">')'</span>;
          element.css({
            <span class="hljs-string">'background-image'</span>: url,
            <span class="hljs-string">'background-size'</span>: <span class="hljs-string">'cover'</span>,
            <span class="hljs-string">'background-repeat'</span>: <span class="hljs-string">'no-repeat'</span>,
            <span class="hljs-string">'background-position'</span>: <span class="hljs-string">'center center'</span>
          });
        });
    };
  }).directive(<span class="hljs-string">'swipeLeft'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">scope, element, attrs</span>) </span>{
      $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        Hammer(element).on(<span class="hljs-string">'swipeleft'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          scope.$<span class="hljs-built_in">eval</span>(attrs.swipeLeft);
          scope.$apply();
        });
      });
    };
  }).directive(<span class="hljs-string">'swipeRight'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">scope, element, attrs</span>) </span>{
      $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        Hammer(element).on(<span class="hljs-string">'swiperight'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          scope.$<span class="hljs-built_in">eval</span>(attrs.swipeRight);
          scope.$apply();
        });
      });
    };
  });</code></pre><p>The calls to <code>$eval</code> evaluate the <code>swipeRight</code> and <code>swipeLeft</code> attributes, which will typically be function calls. For example, in our <a href="http://jsfiddle.net/vkarpov15/5vajr/">little carousel JSFiddle</a>, these calls will look something like this:</p>
<pre><code>&lt;div  my-background-image=<span class="hljs-string">'image'</span>
      swipe-left=<span class="hljs-string">'nextImage()'</span>
      swipe-right=<span class="hljs-string">'prevImage()'</span>&gt;
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>Notice that in the second image, we only allow the user to swipe left, whereas on the first one we allow swiping both left and right. Our <code>swipeLeft</code> and <code>swipeRight</code> directives are completely decoupled from the actual carousel implementation - we can use them anywhere to handle any sort of action we want to take when the user swipes on any element.</p>
<p>In contrast, this is a far cry from the mostly equivalent jQuery implementation (<a href="http://jsfiddle.net/vkarpov15/GWZj3/">view on JSFiddle</a>), where we declare our Hammer.js handlers in jQuery (lines 46 and 47) and have no way of reusing them from HTML. We also have no easy way of allowing only &quot;swipe left&quot; without having to deal with some sort of configuration object. One potential alternative is to expose swipe left and swipe right as separate attributes (similar to our approach with the <code>cover-background-image</code> function), but then we run into a brick wall with scoping - we don&#39;t have an easy way to allow these event handlers to access the <code>previousImage</code> and <code>nextImage</code> functions within the <code>cover-background-image</code> code.</p>
<h2 id="basic-directive-design-pattern-combining-watch-and-update-with-eval-on-an-external-event-handler">Basic Directive Design Pattern: Combining &quot;watch and update&quot; with <code>$eval</code> on an external event handler</h2>
<p><em>Example: Wiring bootstrap-slider to work with AngularJS</em></p>
<p><em>Alternative Example: <a href="https://github.com/angular-ui/bootstrap/blob/master/src/buttons/buttons.js">angular-ui/bootstrap&#39;s btnRadio directive</a></em></p>
<p>Most directives will need data to go both ways. You will need to a) update your view to reflect internal state, and b) define some set of UI-accessible user behaviors that can update the internal state.</p>
<p>First, take a look at <a href="http://www.eyecon.ro/bootstrap-slider/">bootstrap-slider</a>. This slider is a simple drag-and-drop interface for setting numerical values. We&#39;re going to use it for controlling which image is displayed in our image carousel. The directive looks like this (view on <a href="http://jsfiddle.net/vkarpov15/zn5AM/">JSFiddle</a>):</p>
<pre><code>angular.
  <span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp'</span>, []).
  directive(<span class="hljs-string">'bootstrapSlider'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">scope, element, attrs</span>) </span>{
      $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> init = scope.$<span class="hljs-built_in">eval</span>(attrs.ngModel);
        <span class="hljs-keyword">var</span> min = scope.$<span class="hljs-built_in">eval</span>(
          attrs.bootstrapSliderMin);
        <span class="hljs-keyword">var</span> max = scope.$<span class="hljs-built_in">eval</span>(
          attrs.bootstrapSliderMax);
        $(element[<span class="hljs-number">0</span>]).slider({
          value : init,
          min : min,
          max : max,
          tooltip : <span class="hljs-string">'hide'</span>
        });

        <span class="hljs-comment">// Update view to reflect model</span>
        scope.$watch(attrs.ngModel, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
          $(element[<span class="hljs-number">0</span>]).slider(<span class="hljs-string">'setValue'</span>, v);
        });

        <span class="hljs-comment">// Update model to reflect view</span>
        $(element[<span class="hljs-number">0</span>]).slider().on(<span class="hljs-string">'slide'</span>,
          <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) </span>{
            scope.$apply(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
              scope[attrs.ngModel] = ev.value;
            });
          });
      });
    };
  });</code></pre><p>The general idea here is that we do both of the first two design patterns in a single directive. We first initialize the slider using:</p>
<pre><code>$(element[<span class="hljs-number">0</span>]).slider({ <span class="hljs-comment">/*config options */</span> });</code></pre><p>Then we use the <code>.on()</code> event handler to watch for changes in the view, and update <code>ngModel</code> to reflect these changes. Note how we make sure to call <code>scope.$apply</code> so that AngularJS knows that something happened.</p>
<p>You may have noticed that we don&#39;t bother with handling updates to the <code>bootstrapSliderMin</code> and <code>bootstrapSliderMax</code> fields. The <code>bootstrap-slider</code> component doesn&#39;t support updating these attributes and improving <code>bootstrap-slider</code> is beyond the scope of this post.</p>
<h2 id="basic-directive-design-pattern-creating-components-with-nesting-and-templating">Basic Directive Design Pattern: Creating Components with Nesting And Templating</h2>
<p><em>Example: The entire carousel as one directive</em></p>
<p><em>Alternative Example: <a href="https://github.com/angular-ui/bootstrap/blob/master/src/rating/rating.js">angular-ui/bootstrap&#39;s rating directive</a></em></p>
<p>So far we&#39;ve put together some very nice decoupled components that we can reuse anywhere. To review:</p>
<ol>
<li>We can attach our <code>swipeLeft</code> and <code>swipeRight</code> directives to any element.</li>
<li>We can easily put in a slider and bind it to any value.</li>
<li>We can display any image cropped to fill a given <code>div</code>.</li>
<li>We can wire these behaviors together in any way we want.</li>
</ol>
<p>So what if we&#39;re going to reuse our carousel over and over again in the same form, and we&#39;d like to keep our UI nice and DRY? Easy! We just need to create a single new directive that wires together all the previous directives into a single carousel directive. If you read the <a href="http://docs.angularjs.org/guide/directive">AngularJS directives documentation</a>, this type of directive is loosely referred to as a component. The term component is not particularly well defined in the context of directives, but you can generally take it to mean a directive which has its own controller and thus can find its own data. A component has the general implication that it needs little to no external data to do its job properly, essentially something that you can put into a page and just let it run in isolation (view on <a href="http://jsfiddle.net/vkarpov15/NGDzm/">JSFiddle</a>).</p>
<pre><code><span class="hljs-keyword">var</span> template =
  <span class="hljs-string">"&lt;div my-background-image='images[index]'"</span> +
  <span class="hljs-string">"     class='tall'"</span> +
  <span class="hljs-string">"     swipe-left='nextImage()'&gt;&lt;/div&gt;"</span> +
  <span class="hljs-string">"&lt;div ng-click='prevImage()' class='pointer'&gt;"</span> +
  <span class="hljs-string">"  Prev"</span> +
  <span class="hljs-string">"&lt;/div&gt;"</span> +
  <span class="hljs-string">"&lt;div ng-click='nextImage()' class='pointer'&gt;"</span> +
  <span class="hljs-string">"  Next"</span> +
  <span class="hljs-string">"&lt;/div&gt;"</span> +
  <span class="hljs-string">"&lt;div id='mySlider'&gt;"</span> +
  <span class="hljs-string">"  &lt;div bootstrap-slider='true'"</span> +
  <span class="hljs-string">"       ng-model='index'"</span> +
  <span class="hljs-string">"       bootstrap-slider-min='0'"</span> +
  <span class="hljs-string">"       bootstrap-slider-max='images.length - 1'&gt;"</span> +
  <span class="hljs-string">"  &lt;/div&gt;"</span> +
  <span class="hljs-string">"&lt;/div&gt;"</span>;

directive(<span class="hljs-string">'carousel'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
 <span class="hljs-keyword">return</span> {
   restrict : <span class="hljs-string">'E'</span>,
   <span class="hljs-built_in">require</span> : <span class="hljs-string">'ngImages'</span>,
   scope : {
     images : <span class="hljs-string">'=ngImages'</span>
   },
   controller : CarouselController,
   template : template,
   link : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">scope, element, attrs</span>) </span>{}
 };
});</code></pre><p>The big difference here is that instead of returning a plain function, we&#39;re now returning an object with a bunch of options. Here&#39;s a brief walkthrough of what the above jibber-jabber actually does:</p>
<ul>
<li><code>restrict : &#39;E&#39;</code> means that this directive can only be used as an element. For example,<pre><code>&lt;carousel ng-images=<span class="hljs-string">"[]"</span> /&gt;</code></pre>will work, but<pre><code>&lt;div carousel=<span class="hljs-string">"true"</span> ng-images=<span class="hljs-string">"[]"</span> /&gt;</code></pre>won&#39;t. Other possible values of this option are detailed in <a href="http://docs.angularjs.org/guide/directive">http://docs.angularjs.org/guide/directive</a></li>
<li><code>require : &#39;ngImages&#39;</code> states that the <code>&lt;carousel&gt;</code> element must have an <code>ng-images</code> attribute; otherwise this directive will not be used on that element.</li>
<li><code>Scope : { images : &#39;=ngImages&#39; }</code> shows that the directive will create a new scope. That scope will have an <code>images</code> variable that is two-way data-bound to the resulting value of <code>ngImages</code>.</li>
<li><code>Controller: &#39;CarouselController&#39;</code> will wrap the template in an element that has <code>ng-controller=&quot;CarouselController&quot;</code></li>
<li><code>template: ...</code> will populate the <code>&lt;carousel&gt;</code> element&#39;s inner HTML. Note that it can access <code>CarouselController</code>&#39;s functions.</li>
<li><code>Link : ...</code> Here, the<pre><code><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">scope, element, attrs</span>) </span>{}</code></pre>syntax that we used in the first three paterns is a convenient shorthand for:<pre><code><span class="hljs-keyword">return</span> {
link : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">scope, element, attrs</span>) </span>{}
};</code></pre>AngularJS lets you do different things with your directive at different steps of its internal processing, providing options like <code>preLink</code>, <code>postLink</code>, <code>compile</code>, etc. If you&#39;re curious, you can read more about them <a href="http://docs.angularjs.org/guide/directive">here</a>, but most of the time you can get away with just using <code>link</code> until you become an AngularJS whiz.</li>
</ul>
<p>Finally, note that in the fiddle, we replaced one carousel with the carousel directive:</p>
<pre><code>&lt;carousel ng-images=<span class="hljs-string">'["http://images2.wikia.nocookie.net/__cb20110811172434/fallingskies/images/f/fd/Totoro_normal.gif", "http://fc03.deviantart.net/fs28/i/2009/250/7/4/MUSASHI_MIYAMOTO_by_BARCYD.jpg", "http://fc08.deviantart.net/fs71/f/2012/066/3/5/goku_happy_by_kzo-d4s20sy.png";]'</span> /&gt;</code></pre><p>while leaving the other one in the old form:</p>
<pre><code>&lt;div  ng-controller=<span class="hljs-string">"CarouselController"</span>
      ng-init=<span class="hljs-string">'setImages(["http://images2.wikia.nocookie.net/__cb20110811172434/fallingskies/images/f/fd/Totoro_normal.gif","http://images.wikia.com/pokemon/images/archive/4/49/20110526012846!Ash_Pikachu.png","http://images2.wikia.nocookie.net/__cb20111231185621/trigun/images/2/2b/Vash1.jpg"])'</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>  <span class="hljs-attr">my-background-image</span>=<span class="hljs-string">'images[index]'</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"wide"</span>
        <span class="hljs-attr">swipe-left</span>=<span class="hljs-string">"nextImage()"</span>
        <span class="hljs-attr">swipe-right</span>=<span class="hljs-string">"prevImage()"</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-click</span>=<span class="hljs-string">"prevImage()"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pointer"</span>&gt;</span>
    Prev
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-click</span>=<span class="hljs-string">"nextImage()"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pointer"</span>&gt;</span>
    Next
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>  <span class="hljs-attr">ng-click</span>=<span class="hljs-string">"images.push('http://upload.wikimedia.org/wikipedia/en/5/59/Himura_Kenshin_OVA.jpg');"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"pointer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>Add Image<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>This illustrates the tradeoff between flexibility and convenience when defining a universal <code>&lt;carousel&gt;</code> directive.  In many cases, that initial work we did to combine the definitions of slider, background image, and swipe directives into a single <code>&lt;carousel&gt;</code> template will save an enormous amount of hassle later.  However, it&#39;s important to recognize the weakness of using a template for your directive- there is no good way to override that template.  Once you define the template, anything using that <code>&lt;carousel&gt;</code> directive will look and behave exactly like the original definition unless you change the template itself.  Personally, I like to separate directives as much as possible for the sake of flexibility, but every project is different so do whatever works for your application.</p>
<h2 id="special-bonus-rule-1-directives-are-already-hard-keep-them-simple-dont-ping-the-server-or-reformat-underlying-data">Special Bonus Rule #1: Directives are already hard, keep them simple. Don&#39;t ping the server or reformat underlying data.</h2>
<p>A brief aside on code modularity: a directive&#39;s functions should almost never be responsible for getting or formatting their own data.  There&#39;s nothing to stop you from using the <code>$http</code> service from within a directive, but this is almost always the wrong thing to do.  Writing a controller to use <code>$http</code> is the right way to do it. A directive already touches a DOM element, which is a very complex object and is difficult to stub out for testing.  Adding network I/O to the mix makes your code that much more difficult to understand and that much more difficult to test. In addition, network I/O locks in the way that your directive will get its data - maybe in some other place you&#39;ll want to have this directive receive data from a socket or take in preloaded data.  Your directive should either take data in as an attribute through scope.$eval and/or have a controller to handle acquiring and storing the data.</p>
<h2 id="the-end">The End</h2>
<p>So, do you feel like a master of AngularJS directives yet? So far we&#39;ve covered the basics of AngularJS directives and the design patterns that go into writing simple ones. Hopefully this blog post will help to reduce the endless wave of Stack Overflow questions asking, &quot;how do I integrate jQuery plugin X with AngularJS?&quot; If you came across this article because someone linked to it from Stack Overflow, welcome! By reading this far, you&#39;ve probably already come across the answer you needed.  If not, leave a comment about your problems and I will be happy to help you figure it out.</p>
<p><em>Chances are that for every question I just answered in this post, you now have three more. What do you want to learn next? What sorts of examples would you like to see in the next blog post? How are you successfully applying the MEAN Stack in your application? Let me know in the comments below!  You can also follow me on Twitter at @Code_Barbarian for random programming insights, news about the MEAN Stack from around the world, and occasional pictures of me eating absurd quantities of food. As always, big thanks to my partners William Kelly (@idostartups) and Cesar Devers (@Cesar_Devers) for their help in putting this post together.</em></p>
</div><div style="color: #666666; border-top: 1px dashed #666666; margin: 25px; text-align: center; padding-top: 10px"><em>Found a typo or error? Open up a pull request! This post is
available as markdown on&nbsp;<a href="https://github.com/vkarpov15/thecodebarbarian.com/blob/master/lib/posts/#{post.src.substr('./lib/posts/'.length)}">Github</a></em></div><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'codebarbarian'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></div></div><div style="padding-bottom: 100px">&nbsp;</div><script type="text/javascript">var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://g0a3nbw0xa.execute-api.us-east-1.amazonaws.com/prod/track', true);
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.onreadystatechange = function() {};
xhr.send(JSON.stringify({
  path: window.location.pathname,
  hostname: window.location.hostname
}));</script><link rel="stylesheet" href="/style/inlinecpc.css"></body></html>