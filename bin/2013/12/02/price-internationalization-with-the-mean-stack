<html><head><script type="text/javascript">var _sf_startpt=(new Date()).getTime()
</script><title>Price Internationalization with the MEAN Stack | www.thecodebarbarian.com</title><meta name="viewport" content="width=device-width, initial-scale=1"/><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" type="text/css"/><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet" type="text/css"/><link href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,600,700" rel="stylesheet" type="text/css"/><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"/><link href="/style/style.css" rel="stylesheet" type="text/css"/><link href="/style/github.css" rel="stylesheet" type="text/css"/><script href="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script><script href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script><script href="/javascript/sidebar.js" type="text/javascript"></script><meta property="og:title" content="Price Internationalization with the MEAN Stack"/><meta property="og:url" content="http://www.thecodebarbarian.com/2013/12/02/price-internationalization-with-the-mean-stack"/><meta property="og:image" content="//thumbs.dreamstime.com/x/small-currency-dice-forex-chart-18044052.jpg"/><meta property="og:site_name" content="The Code Barbarian"/></head><body><div class="navbar social-links hidden-sm hidden-xs"><div class="container"><ul class="nav navbar-nav navbar-right"><li><a href="http://www.twitter.com/code_barbarian">twitter</a></li><li><a href="http://www.github.com/vkarpov15">github</a></li></ul></div></div><div id="nav" class="navbar"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#home-nav-mobile" class="btn btn-default navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand big-brand"><img src="/images/Barbarian_Head.png" class="logo"/><span class="site-name">The Code Barbarian  </span></a></div><div id="home-nav-mobile" class="navbar-right collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href="/tag/mongodb">MongoDB</a></li><li><a href="/tag/angularjs">AngularJS</a></li><li><a href="/tag/nodejs">NodeJS</a></li><li><a href="/tag/paleo">Paleo</a></li><li class="hidden-md hidden-lg"><a href="#">@code_barbarian</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Github</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Facebook</a></li></ul></div></div></div><div class="container-fluid"><div id="desktop-right-bar" class="col-lg-3 col-lg-offset-9 right-bar"><div class="right-bar-content-slider pull-right"><div class="row search-container"><div class="col-lg-12"><div class="form-group"></div><label>Search</label><form onsubmit="window.location.href = 'https://www.google.im/search?q=' + encodeURIComponent(document.getElementById('searchQ').value) + '+site:thecodebarbarian.com'; return false;"><div class="input-group"><input id="searchQ" type="text" class="form-control"/><div class="input-group-addon search-button"><i class="fa fa-search"></i></div></div></form></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12"><p class="right-bar-label">All Time Most Popular </p><ul class="list-unstyled"><li class="right-bar-li"><a href="/2013/07/22/introduction-to-the-mean-stack-part-one-setting-up-your-tools/">Introduction to the MEAN Stack, Part One: Setting Up Your Tools</a></li><li class="right-bar-li"><a href="/2013/09/23/the-8020-guide-to-writing-angularjs-directives/">The 80/20 Guide to Writing AngularJS Directives</a></li><li class="right-bar-li"><a href="/2013/07/29/introduction-to-the-mean-stack-part-two-building-and-testing-a-to-do-list/">Introduction to the MEAN Stack, Part Two: Building and Testing a To-do List</a></li><li class="right-bar-li"><a href="/2013/05/12/how-to-easily-validate-any-form-ever-using-angularjs/">How to Easily Validate Any Form Ever Using AngularJS</a></li></ul></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12"><p class="right-bar-label">Recent Posts</p><ul class="list-unstyled"><li class="right-bar-li"><a href="/2015/04/10/shippable-an-alternative-take-on-travis">Shippable: An Alternative Take on Travis</a></li><li class="right-bar-li"><a href="/2015/03/20/callback-hell-is-a-myth">Callback Hell is a Myth</a></li><li class="right-bar-li"><a href="/2015/03/13/testing-rest-apis-with-acquit">Testing and Documenting Node.js APIs with Mocha and Acquit</a></li><li class="right-bar-li"><a href="/2015/03/06/guide-to-mongoose-plugins">An 80/20 Guide to Mongoose Plugins</a></li></ul></div></div></div></div></div><div id="mobile-sharing-options" class="container-fluid hidden-sm hidden-md hidden-lg"><div class="row"><div class="col-lg-12"><div class="post-sharing-options"><div class="row"><div class="col-xs-3 twitter-share sharing-option"><a href="https://twitter.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2F2013%2F12%2F02%2Fprice-internationalization-with-the-mean-stack&amp;via=code_barbarian" class="social"><i class="fa fa-twitter"></i></a></div><div class="col-xs-3 facebook-share sharing-option"><a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2F2013%2F12%2F02%2Fprice-internationalization-with-the-mean-stack" class="social"><i class="fa fa-facebook"></i></a></div><div class="col-xs-3 google-share sharing-option"><a href="https://plus.google.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2F2013%2F12%2F02%2Fprice-internationalization-with-the-mean-stack" class="social"><i class="fa fa-google-plus"></i></a></div><div class="col-xs-3 comment sharing-option"><a href="#disqus_thread" class="social"><i class="fa fa-comment"></i></a></div></div></div></div></div></div><div id="desktop-sharing-options" class="post-sharing-options hidden-xs pull-left"><ul class="list-unstyled"><li class="twitter-share"><a href="https://twitter.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2F2013%2F12%2F02%2Fprice-internationalization-with-the-mean-stack&amp;via=code_barbarian" class="social"><i class="fa fa-twitter sharing-option"></i></a></li><li class="facebook-share"><a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2F2013%2F12%2F02%2Fprice-internationalization-with-the-mean-stack" class="social"><i class="fa fa-facebook sharing-option"></i></a></li><li class="google-share"><a href="https://plus.google.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2F2013%2F12%2F02%2Fprice-internationalization-with-the-mean-stack" class="social"><i class="fa fa-google-plus sharing-option"></i></a></li></ul></div><div class="container"><div class="col-lg-9 post-text"><div class="row"><div class="title-byline-container"><h1 class="post-title">Price Internationalization with the MEAN Stack </h1><div class="credits"><span class="byline">by Valeri Karpov</span><span class="byhandle"><a href="http://www.twitter.com/code_barbarian">@code_barbarian</a></span><span class="bydate">December 02, 2013</span></div></div><a href="https://github.com/vkarpov15/mean-exchange-rates"><div class="source-code-button"><div class="btn btn-orange btn-block"><i class="fa fa-github-alt"></i><span class="hidden-lg hidden-md hidden-sm">View the Code on Github</span><span class="hidden-xs">View the Code for this Post on Github</span></div></div></a></div><div class="post-body-text-container"><p>Displaying prices in different currencies is a common internationalization task for web developers. However, this task can be a bit tricky:</p>
<ul>
<li>While there are a number of services that provide foreign exchange rates, they are usually expensive, especially for a high volume of requests.</li>
<li>Unless you make a request for updated exchange rates every time a user loads a page, you will need to find some way to schedule your requests.</li>
</ul>
<p>In this post we&#39;ll walk through how to build this functionality into your next website with the MEAN Stack (MongoDB, Node.js, AngularJS, and ExpressJS). The code for this example is available on <a href="https://github.com/vkarpov15/mean-exchange-rates">Github</a>, in case you want to skip straight to the code.</p>
<h2 id="the-problem">The Problem</h2>
<p>Let&#39;s say that we have an online store where we sell watches from James Bond films. Naturally, since the last film <em>Skyfall</em> grossed over $700M outside the US, we would like to make the shopping experience for our international customers as seamless as for domestic customers. A big part of this is showing our prices in our customer&#39;s local currency, because the vast majority of our customers will only have a vague idea of the exchange rate between their local currency and US dollars. Here are 3 pictures representing the behavior we want to have:</p>
<p>Our shopper loads the page and sees the price of the watch in US Dollars:</p>
<p><a href="http://thecodebarbarian.files.wordpress.com/2013/12/currency1.png"><img src="http://thecodebarbarian.files.wordpress.com/2013/12/currency1.png" style="width: 100%"></a></p>
<p>Our shopper decides they want to see the prices in Turkish Lira, so they find the currency in our dropdown:</p>
<p><a href="http://thecodebarbarian.files.wordpress.com/2013/12/currency2.png"><img src="http://thecodebarbarian.files.wordpress.com/2013/12/currency2.png" style="width: 100%"></a></p>
<p>When our shopper clicks Turkish Lira, our page updates without a page refresh to show how much our watches cost in the selected currency.</p>
<p><a href="http://thecodebarbarian.files.wordpress.com/2013/12/currency3.png"><img src="http://thecodebarbarian.files.wordpress.com/2013/12/currency3.png" style="width: 100%"></a></p>
<h2 id="general-idea-for-the-solution">General idea for the solution</h2>
<p>In the past, I&#39;ve used the <a href="https://openexchangerates.org/">Open Exchange Rates API</a>, which offers 1000 free requests per month. 1000 requests may sound like a lot, but if you&#39;re requesting the rates every time a user loads a page, you&#39;re probably going to hit 1000 requests just testing your site. Furthermore, you&#39;re making an extra HTTP request each time you load the page, so you&#39;re wasting both time and money. How can we do better? What if we could request foreign exchange rates once per day?</p>
<p>Intraday changes in exchange rates are usually pretty insignificant unless you&#39;re dealing with millions of dollars. For example, the exchange rate from Euros to US Dollars, abbreviated EUR/USD, is so steady that a change of 0.02 in a single day is <a href="http://finance.yahoo.com/news/eur-usd-largest-one-day-215100423.html">headline news</a>. You may want more precise rates, but for the sake of this blog post we&#39;ll assume that we can get away with reloading our rates once every 24 hours. We can then store the rates on our server and serve them up inlined in our HTTP responses.</p>
<p>However, making an HTTP request daily and loading the results into your server is a problem with many subtleties. You need some way to schedule the HTTP request to run and you need some sort of concurrent I/O to keep the data in memory. The canonical language-independent solution would involve setting up a cron job on your Linux server which writes the output to a file, and then read the file every time you want to access your exchange rates.</p>
<p>As you might have guessed, the cron job solution is riddled with complexity and difficulty. Cron jobs are platform-specific, difficult to test, and add extra complexity to setting up your server. If I had a dollar for every time I ran into a bug because a cron job was running a script as a different user, I&#39;d have enough money to buy myself the <a href="http://www.amazon.com/Omega-Seamaster-Planet-Chrono-232-92-46-51-03-001/dp/B00CJG2K56/ref=sr_1_2?ie=UTF8&amp;qid=1408977805&amp;sr=8-2&amp;keywords=omega+seamaster+planet+ocean+600m">Omega Seamaster</a> from the watch store in this example. Furthermore, if you want to set up your cron job on your Windows laptop, good luck. Finally, you&#39;ll run into one more subtle issue. When you dump the data to a file, you don&#39;t have a good way to query or maintain historical exchange rates, but if you want to save this data to an SQL database, the effort of setting up a separate column for every currency simply isn&#39;t worth the work.</p>
<p>Thankfully, with NodeJS and MongoDB, these problems disappear. In NodeJS, you have absolutely no excuse to use cron jobs. <a href="https://github.com/ncb000gt/node-cron">Node-cron</a> is a very small and simple npm library that provides a wrapper around Javascript&#39;s <code>setTimeout</code> and <code>setInterval</code> functions using scheduling syntax similar to a standard unix cron job. Best of all, this runs in the server&#39;s memory space, so you don&#39;t have to dump the data to a file before pulling it into your server. MongoDB allows you to simply save the JSON data you receive from Open Exchange Rates as-is, with no extra work of setting up columns, while providing you with the ability to run sophisticated queries on your data.</p>
<h2 id="implementing-the-solution">Implementing the solution</h2>
<p>In this section, we&#39;re going to walk through internationalizing the prices for our example online watch store. The finished code for is located <a href="https://github.com/vkarpov15/mean-exchange-rates">here</a>, in case you prefer to dig right in to the code. This repo started as a <a href="https://help.github.com/articles/duplicating-a-repository">bare clone</a> of <a href="https://github.com/vkarpov15/mean-stack-skeleton">mean-stack-skeleton</a>.</p>
<h2 id="1-querying-and-storing-foreign-exchange-rates-snapshots">1) Querying and storing foreign exchange rates snapshots</h2>
<p>First things first, lets write a MongooseJS model for our FX data <a href="https://github.com/vkarpov15/mean-exchange-rates/blob/master/models/FxSnapshot.js#L10-18">(github)</a>:</p>
<pre><code><span class="hljs-keyword">var</span> Mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);

exports.FxSnapshotSchema = <span class="hljs-keyword">new</span> Mongoose.Schema({
<span class="hljs-comment">// The time that the snapshot was taken</span>
  time : { type : <span class="hljs-built_in">Date</span>, <span class="hljs-keyword">default</span> : <span class="hljs-built_in">Date</span>.now },
  <span class="hljs-comment">// Means that 'rates' can be anything</span>
  rates : Mongoose.Schema.Types.Mixed
});

<span class="hljs-comment">// Make sure we have an index on the time of the snapshot</span>
exports.FxSnapshotSchema.index({ <span class="hljs-string">'time'</span> : -<span class="hljs-number">1</span> });
</code></pre><p>And a simple NodeJS function which uses the request module to ping the Open Exchange Rates API and saves an FxSnapshot to the database <a href="https://github.com/vkarpov15/mean-exchange-rates/blob/master/fx_rates.js#L4-21">(github)</a>:</p>
<pre><code><span class="hljs-keyword">var</span> refresh = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> </span>{
  console.log(<span class="hljs-string">'Refreshing exchange rates'</span>);
  request(<span class="hljs-string">'http://openexchangerates.org/api/latest.json?app_id='</span> + key,
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error, response, body)</span> </span>{
      <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">callback</span>(error);
      }

      rates = JSON.parse(body).rates;

      <span class="hljs-keyword">var</span> snapshot = <span class="hljs-keyword">new</span> FxSnapshot({ rates : rates });
      snapshot.save(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error, snapshot)</span> </span>{
        <span class="hljs-comment">// Should never fail</span>
      });

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">callback</span>(<span class="hljs-literal">null</span>, rates);
    });
};
</code></pre><h2 id="2-set-up-rules-for-when-to-query-for-new-rates">2) Set up rules for when to query for new rates</h2>
<p>Now that we have a function to load data, the question is, how do we use it? The start of the FX trading day is 5:30 pm New York time Sunday-Thursday, with the exception of New Zealand Dollar markets, so querying once a day at 6pm is a reasonable approximation to getting the market open. We can do this using node-cron. Note that this example presumes that you are in EST - if you want to query at 6pm EST from a server in a different time zone, you need to adjust the below code accordingly. If you are not familiar with cron job syntax, the <a href="https://github.com/ncb000gt/node-cron">node-cron Github repo</a> has a few examples.</p>
<pre><code><span class="hljs-keyword">var</span> job = <span class="hljs-keyword">new</span> cron.CronJob(<span class="hljs-string">'00 00 18 * * 0-6'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  refresh(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{});
});
job.start();
</code></pre><p>But what happens on server restart? Our exchange rates are stored in memory and persisted to MongoDB, so if our application server crashes, we need to get the exchange rates back on restart. In addition, if our server was down at 6pm and thus didn&#39;t query for new rates, we don&#39;t want to be showing rates that are excessively stale. To take care of these issues, lets add an initialization function that will load the latest snapshot from MongoDB, and refresh if the snapshot is more than a day old:</p>
<pre><code><span class="hljs-keyword">var</span> init = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span> </span>{
  <span class="hljs-comment">// Find the latest snapshot</span>
  FxSnapshot.findOne({}).sort({ time : -<span class="hljs-number">1</span> }).exec(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error, snapshot)</span> </span>{
    <span class="hljs-keyword">if</span> (error || !snapshot) {
      refresh(<span class="hljs-keyword">callback</span>);
    } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// If data is more than 1 day stale</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> Date(snapshot.time).getTime() + <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span> &lt; <span class="hljs-keyword">new</span> Date().getTime()) {
        refresh(<span class="hljs-keyword">callback</span>);
      } <span class="hljs-keyword">else</span> {
        rates = snapshot.rates;
        <span class="hljs-keyword">callback</span>(<span class="hljs-literal">null</span>, snapshot.rates);
      }
    }
  });
};
</code></pre><p>Finally, lets wrap the entire <code>FxRates</code> module in a pretty bow and make a convenient interface available to the rest of our code:</p>
<pre><code><span class="hljs-keyword">return</span> {
  refresh : refresh,
  init : init,
  <span class="hljs-keyword">get</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> rates;
  }
};
</code></pre><p>Note that the <code>get()</code> function just returns the rates object as-is. Those not familiar with NodeJS may wonder how this can possibly be thread-safe. Conveniently, NodeJS is event-driven, so there are no threads. Without getting into too much detail about event-driven concurrency, just know that there is no way that <code>get()</code> will return a partially written version of rates, because the following code in the <code>refresh()</code> function is guaranteed to execute sequentially without any other code executing in the meantime:</p>
<pre><code><span class="hljs-title">if</span> (<span class="hljs-built_in">error</span>) {
  <span class="hljs-title">return</span> callback(<span class="hljs-built_in">error</span>);
}

<span class="hljs-title">rates</span> = JSON.parse(body).rates;

<span class="hljs-title">var</span> snapshot = new FxSnapshot({ <span class="hljs-title">rates</span> : rates });
</code></pre><h2 id="3-displaying-this-information-to-the-user">3) Displaying this information to the user</h2>
<p>Now that we have a tool to pull exchange rates regularly, lets create a schema for the products that we&#39;re going to display <a href="https://github.com/vkarpov15/mean-exchange-rates/blob/master/models/Product.js#L10-17">(Github)</a>. In particular, we want to keep track of the currency&#39;s list price, so we&#39;re not tied to US Dollars.</p>
<pre><code>exports.ProductSchema = <span class="hljs-keyword">new</span> Mongoose.Schema({
  <span class="hljs-string">name :</span> String,
  <span class="hljs-string">price :</span> {
    <span class="hljs-string">price :</span> Number,
    <span class="hljs-string">currency :</span> String
  },
  <span class="hljs-string">picture :</span> String
});
</code></pre><p>Lets also define a route that depends on this model and our <code>FxRates</code> module:</p>
<pre><code>app.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/'</span>, routes.index(FxRates, Product));

<span class="hljs-comment">/*
 * GET home page
 */</span>
exports.index = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(FxRates, Product)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
    <span class="hljs-comment">// Load all products</span>
    Product.find({}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error, products)</span> </span>{
      res.render(<span class="hljs-string">'index'</span>, { products : products, rates : FxRates.<span class="hljs-keyword">get</span>() });
    });
  };
};
</code></pre><p>And now that we&#39;ve done the hard part, we can put together the <a href="https://github.com/vkarpov15/mean-exchange-rates/blob/master/views/index.jade">index.jade view</a>, which will have a drop-down where the user can select their preferred currency. At this point, I&#39;d recommend you play with the code yourself - you can set up NodeJS and MongoDB as described <a href="http://thecodebarbarian.com/2013/07/22/introduction-to-the-mean-stack-part-one-setting-up-your-tools/">here</a>, get yourself an Open Exchange Rates API key, and run the server with</p>
<pre><code>node app.js --<span class="hljs-variable">key</span> [your Open Exchange Rates API <span class="hljs-variable">key</span> here]
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>Hopefully now you&#39;ve seen why the MEAN stack makes it exceptionally easy to integrate multiple currency display into your site. With NodeJS, you can take advantage of event-driven I/O to write some sophisticated concurrency into your server with ease. With MongoDB, you can store semi-structured data in a form that you can query back later. Hopefully after this post, you won&#39;t be quite as intimidated as I was the first time I was asked to build out a tool to display prices in different currencies.</p>
</div><div style="color: #666666; border-top: 1px dashed #666666; margin: 25px; text-align: center; padding-top: 10px"><em>Found a typo or error? Open up a pull request! This post is
available as markdown on&nbsp;<a href="https://github.com/vkarpov15/thecodebarbarian.com/blob/master/lib/posts/20131202_currencies.md">Github</a></em></div><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'codebarbarian'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div></div><div style="padding-bottom: 100px">&nbsp;</div><script type="text/javascript">!function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.0.1";
  analytics.load("5DErrxzVhprg8sNh8xaiKDR6dNa7yGTI");
  analytics.page()
}}();</script><script type="text/javascript">analytics.track('opened post',
  { title: "Price Internationalization with the MEAN Stack", time: new Date() });
  </script></body></html>