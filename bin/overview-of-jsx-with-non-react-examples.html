<!DOCTYPE html><html><head><script type="text/javascript">var _sf_startpt=(new Date()).getTime()
</script><title>An Overview of JSX With 3 Non-React Examples | www.thecodebarbarian.com</title><meta name="viewport" content="width=device-width, initial-scale=1"><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,600,700" rel="stylesheet" type="text/css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"><link href="/style/style.css" rel="stylesheet" type="text/css"><link href="/style/github.css" rel="stylesheet" type="text/css"><script href="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script><script href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script><script href="/javascript/sidebar.js" type="text/javascript"></script><meta property="og:title" content="An Overview of JSX With 3 Non-React Examples"><meta property="og:url" content="http://www.thecodebarbarian.com/overview-of-jsx-with-non-react-examples"><meta property="og:image" content="https://codebarbarian-images.s3.amazonaws.com/southpointe.jpg"><meta property="og:site_name" content="The Code Barbarian"><meta property="description" content="JSX is an extension of the JavaScript language that supports XML-like syntax. While JSX is usually used for React, it doesn't have to be - here's 3 examples that don't involve React."><meta name="twitter:image" content="https://codebarbarian-images.s3.amazonaws.com/southpointe.jpg"></head><body><div class="navbar social-links hidden-sm hidden-xs"><div class="container"><ul class="nav navbar-nav navbar-right"><li><a href="http://www.twitter.com/code_barbarian">twitter</a></li><li><a href="http://www.github.com/vkarpov15">github</a></li><li><a href="http://thecodebarbarian.com/feed.xml">rss</a></li><li><a href="/recommendations">recommendations</a></li></ul></div></div><div class="navbar" id="nav"><div class="container"><div class="navbar-header"><a class="navbar-brand big-brand" href="http://thecodebarbarian.com"><img class="logo" src="/images/Barbarian_Head.png"><span class="site-name">The Code Barbarian</span></a></div><div class="navbar-right collapse navbar-collapse" id="home-nav-mobile"><ul class="nav navbar-nav"><li><a href="/tag/mongodb.html">MongoDB</a></li><li><a href="/tag/nodejs.html">NodeJS</a></li><li><a href="/tag/asyncawait.html">Async/Await</a></li><li><a href="/tag/vue.html">Vue</a></li><li class="hidden-md hidden-lg"><a href="#">@code_barbarian</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Github</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Facebook</a></li></ul></div></div></div><div class="container-fluid"><div class="col-lg-3 col-lg-offset-9 right-bar" id="desktop-right-bar"><div class="right-bar-content-slider pull-right"><div class="row recent-posts right-bar-group"><div class="col-lg-12 articles"><p class="right-bar-label">Most Popular Articles</p><ul class="list-unstyled"><li class="right-bar-li"><a href="/common-async-await-design-patterns-in-node.js.html">Common Async/Await Design Patterns in Node.js</a></li><li class="right-bar-li"><a href="/unhandled-promise-rejections-in-node.js.html">Unhandled Promise Rejections in Node.js</a></li><li class="right-bar-li"><a href="/using-async-await-with-mocha-express-and-mongoose">Using Async/Await with Mocha, Express, and Mongoose</a></li><li class="right-bar-li"><a href="/write-your-own-node-js-promise-library-from-scratch.html">Write Your Own Node.js Promise Library from Scratch</a></li><li class="right-bar-li"><a href="/80-20-guide-to-express-error-handling">The 80/20 Guide to Express Error Handling</a></li></ul></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12 books"><p class="right-bar-label">Ebooks<div><a href="http://asyncawait.net/?utm_source=thecodebarbarian&amp;utm_campaign=sidebar"><img src="/images/verticalbanner.png"></a></div><div><a href="http://es2015generators.com"><img src="https://i.imgur.com/xvGNKlr.png"><p><i>The 80/20 Guide to ES2015 Generators</i></p></a></div><div><script type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&amp;serve=C6AILKT&amp;placement=thecodebarbariancom" id="_carbonads_js"></script></div></p></div></div></div></div></div><div class="container-fluid hidden-sm hidden-md hidden-lg" id="mobile-sharing-options"><div class="row"><div class="col-lg-12"><style>#home-nav-mobile {
  float: left !important;
  margin-left: 215px !important;
}
</style><div class="post-sharing-options"><div class="row"><div class="col-xs-3 twitter-share sharing-option"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter"></i></a></div><div class="col-xs-3 facebook-share sharing-option"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook"></i></a></div><div class="col-xs-3 google-share sharing-option"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus"></i></a></div><div class="col-xs-3 comment sharing-option"><a class="social" href="#disqus_thread"><i class="fa fa-comment"></i></a></div></div></div></div></div></div><div class="post-sharing-options hidden-xs pull-left" id="desktop-sharing-options"><ul class="list-unstyled"><li class="twitter-share"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter sharing-option"></i></a></li><li class="facebook-share"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook sharing-option"></i></a></li><li class="google-share"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus sharing-option"></i></a></li></ul></div><div class="container"><div class="col-lg-9 post-text"><div class="row"><div class="title-byline-container"><h1 class="post-title">An Overview of JSX With 3 Non-React Examples</h1><div class="credits"><span class="byline">by Valeri Karpov</span><span class="byhandle"><a href="http://www.twitter.com/code_barbarian">@code_barbarian</a></span><span class="bydate">January 21, 2020</span></div></div></div><script type="text/javascript" src="/js/native.js"></script><div><script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>

<div class="native-banner"></div>

<script>
  (function(){
    if(typeof _bsa !== 'undefined' && _bsa) {
      _bsa.init('custom', 'CK7DT53N', 'placement:thecodebarbariancom', { target: '.native-banner', template: `
      <div class="native-container">
        <a href="##link##" class="native-banner">
              <div class="native-img" style="background: ##backgroundColor##;"><img src="##logo##"></div>
              <div class="native-details">
                <span class="native-desc"><strong>##company##</strong> ##description##</span>
              </div>
          </a>
          <a class="native-via" href="##adViaLink##"">Ad via BuySellAds</a>
      </div>
      `, }
      );
    }
  })();
</script>
</div><div class="post-body-text-container"><p><a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a> is an extended
JavaScript syntax popularized by React. The fundamental issue that
JSX was designed to solve is that writing React code in vanilla
JavaScript was simply too cumbersome:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// With JSX</span>
<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Contacts<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"mailto:test1@test.com"</span>&gt;</span>test1@test.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"mailto:test2@test.com"</span>&gt;</span>test2@test.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
)</span>;

<span class="hljs-comment">// Without JSX</span>
<span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">'div'</span>, {}, 
  React.createElement(<span class="hljs-string">'h1'</span>, {}, <span class="hljs-string">'Contacts'</span>),
  React.createElement(<span class="hljs-string">'ul'</span>, {},
    React.createElement(<span class="hljs-string">'li'</span>, {},
      React.createElement(<span class="hljs-string">'a'</span>, {href: <span class="hljs-string">'mailto:test1@test.com'</span>}, <span class="hljs-string">'test1@test.com'</span>)
    ),
    React.createElement(<span class="hljs-string">'li'</span>, {},
      React.createElement(<span class="hljs-string">'a'</span>, {href: <span class="hljs-string">'mailto:test2@test.com'</span>}, <span class="hljs-string">'test2@test.com'</span>)
    )
  )
);</code></pre>
<p>With the meteoric rise of the popularity of transpilers in 2015,
largely due to delays in finalizing and adopting ES6, JSX became
much more convenient. JSX let you essentially write HTML in your
JavaScript, including syntax highlighting for the HTML portions
Everyone was using transpilers anyway,
what was one more syntactic extension?</p>
<p>But what does JSX actually do?</p>
<h2 id="jsx-under-the-hood">JSX Under the Hood</h2>
<p>According to the <a href="https://facebook.github.io/jsx/">JSX Spec Draft</a>,
JSX adds two new <a href="https://masteringjs.io/tutorials/fundamentals/expressions">expressions</a> to JavaScript syntax:</p>
<ul>
<li><code>JSXElement</code></li>
<li><code>JSXFragment</code></li>
</ul>
<p>A <code>JSXElement</code> is any JavaScript expression that starts with a <code>&lt;</code>. This
doesn&#39;t conflict with the <code>&lt;</code> operator in JavaScript because starting
an expression with <code>&lt;</code> is a syntax error.</p>
<pre><code class="language-javascript">x &lt; <span class="hljs-number">5</span>; <span class="hljs-comment">// OK</span>

&lt; <span class="hljs-number">5</span>; <span class="hljs-comment">// SyntaxError: Unexpected token &lt;</span></code></pre>
<p>A <code>JSXElement</code> is a recursive structure that the compiler is responsible
for converting into function calls. Below is an example of nested <code>JSXElement</code>
declarations:</p>
<pre><code class="language-javascript">&lt;Node hello=<span class="hljs-string">"world"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">"bar"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Node</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Node</span>&gt;</span></span></code></pre>
<p>The <a href="https://babeljs.io/en/repl">JSX compiler</a> converts the above syntax
into the following JavaScript:</p>
<pre><code class="language-javascript">React.createElement(Node, { hello: <span class="hljs-string">'world'</span> },
  React.createElement(Node, { foo: <span class="hljs-string">'bar'</span> })
);</code></pre>
<p>The JSX compiler converts the <code>&lt;Node prop=&quot;hello&quot;&gt;...</code> syntax into
3 function parameters:</p>
<ul>
<li><code>elementType</code>: the type of the node. In this case, <code>Node</code>.</li>
<li><code>props</code>: a POJO containing the <a href="https://www.w3schools.com/html/html_attributes.asp">attributes</a>. In this case, <code>{ hello: &#39;world&#39; }</code></li>
<li><code>children</code>: the rest of the parameters are the children of this element. In this case, it is the child <code>Node</code> element.</li>
</ul>
<p>The JSX compiler parses all the element types, props, and children, and
passes each of the nodes in the tree through a <a href="https://www.gatsbyjs.org/blog/2019-08-02-what-is-jsx-pragma/">pragma</a>. The <em>pragma</em> is just a fancy term for the
function that JSX calls on each node. In the previous case, <code>React.createElement</code>
was the pragma. But you can configure the pragma using an <code>/** @jsx */</code> comment:</p>
<pre><code class="language-javascript"><span class="hljs-comment">/** @jsx MyPragma */</span>

&lt;Node prop=<span class="hljs-string">"hello"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"world"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Node</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Node</span>&gt;</span></span></code></pre>
<p>A JSX compiler would compile the above code into the below JavaScript:</p>
<pre><code class="language-javascript"><span class="hljs-comment">/** @jsx MyPragma */</span>
MyPragma(Node, { prop: <span class="hljs-string">'hello'</span> },
  MyPragma(Node, { prop: <span class="hljs-string">'world'</span> }));</code></pre>
<p>A <code>JSXFragment</code> is simply a list of <code>JSXElement</code>s without a parent.
For the purposes of this article, I&#39;ll ignore fragments. You can
<a href="https://reactjs.org/docs/fragments.html">read more about fragments here</a>.</p>
<p>With different pragmas, JSX has some neat alternative use cases.
Below are a few examples.</p>
<h2 id="building-a-tree">Building a Tree</h2>
<p>Suppose you have a simple <a href="/i-dont-want-to-hire-you-if-you-cant-reverse-a-binary-tree">binary tree</a> class:</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">val, left, right</span>) </span>{
  <span class="hljs-keyword">this</span>.val = val;
  <span class="hljs-keyword">this</span>.left = left;
  <span class="hljs-keyword">this</span>.right = right;
}</code></pre>
<p>Building a tree in vanilla JavaScript can get a little messy.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> tree = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">12</span>,
  <span class="hljs-keyword">new</span> Node(<span class="hljs-number">9</span>),
  <span class="hljs-keyword">new</span> Node(<span class="hljs-number">16</span>,
    <span class="hljs-keyword">new</span> Node(<span class="hljs-number">14</span>)
  )
);</code></pre>
<p>The above looks an awful lot like the unwieldy <code>react.CreateElement()</code> calls.
You can use JSX to make defining a tree look much cleaner:</p>
<pre><code class="language-javascript"><span class="hljs-comment">/** @jsx pragma */</span>

<span class="hljs-keyword">const</span> tree = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"12"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"9"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"14"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Node</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"16"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Node</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Node</span>&gt;</span>;</span>

<span class="hljs-built_in">console</span>.log(tree);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pragma</span>(<span class="hljs-params">Element, props, left, right</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Element(props.value, left, right);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">val, left, right</span>) </span>{
  <span class="hljs-keyword">this</span>.val = val;
  <span class="hljs-keyword">this</span>.left = left;
  <span class="hljs-keyword">this</span>.right = right;
}</code></pre>
<p>Once compiled, the above JSX looks like this:</p>
<pre><code class="language-javascript"><span class="hljs-comment">/** @jsx pragma */</span>
<span class="hljs-keyword">var</span> tree = pragma(Node, {
  value: <span class="hljs-string">"12"</span>
}, pragma(Node, {
  value: <span class="hljs-string">"9"</span>
}), pragma(Node, {
  value: <span class="hljs-string">"14"</span>
}, pragma(Node, {
  value: <span class="hljs-string">"16"</span>
})));
<span class="hljs-built_in">console</span>.log(tree);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pragma</span>(<span class="hljs-params">Element, props, left, right</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Element(props.value, left, right);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">val, left, right</span>) </span>{
  <span class="hljs-keyword">this</span>.val = val;
  <span class="hljs-keyword">this</span>.left = left;
  <span class="hljs-keyword">this</span>.right = right;
}</code></pre>
<p>And gives you the below output:</p>
<pre><code>Node {
  val: &#39;12&#39;,
  left: Node { val: &#39;9&#39;, left: undefined, right: undefined },
  right:
   Node {
     val: &#39;14&#39;,
     left: Node { val: &#39;16&#39;, left: undefined, right: undefined },
     right: undefined } }</code></pre><h2 id="express-route-definitions">Express Route Definitions</h2>
<p><a href="http://expressjs.com/">Express</a> is a popular HTTP server framework for Node.js.
You can define an Express app by listing out method calls:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);

<span class="hljs-keyword">const</span> app = express();
app.get(<span class="hljs-string">'/status'</span>, getStatus);

<span class="hljs-comment">// Nested sub-app</span>
<span class="hljs-keyword">const</span> apiSubapp = express.Router();
apiSubapp.get(<span class="hljs-string">'/version'</span>, getVersion);
app.use(<span class="hljs-string">'/api'</span>, apiSubapp);</code></pre>
<p>You may use JSX to convert a XML-like route definition into
Express <code>.get()</code> and <code>.use()</code> calls, as long as you use the
right pragma. The key detail to note is that whatever the
<code>pragma()</code> function returns for the child elements, that is
what the parent node gets as <code>children</code>.</p>
<pre><code class="language-javascript"><span class="hljs-comment">/** @jsx pragma */</span>

<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);

<span class="hljs-keyword">const</span> App = () =&gt; {};
<span class="hljs-keyword">const</span> Get = () =&gt; {};
<span class="hljs-keyword">const</span> Router = () =&gt; {};

<span class="hljs-keyword">const</span> app = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Get</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/status"</span> <span class="hljs-attr">handler</span>=<span class="hljs-string">{getStatus}</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Router</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/api"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Get</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/version"</span> <span class="hljs-attr">handler</span>=<span class="hljs-string">{getVersion}</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">App</span>&gt;</span>;</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pragma</span>(<span class="hljs-params">Element, props</span>) </span>{
  <span class="hljs-keyword">const</span> children = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);
  <span class="hljs-keyword">if</span> (Element === App) {
    <span class="hljs-keyword">const</span> app = express();
       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> children) {
      app[child.method](child.path, child.handler);
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Element === Get) {
    <span class="hljs-comment">// Whatever you return here, the parent `App` or `Router` gets as</span>
    <span class="hljs-comment">// a `child`.</span>
       <span class="hljs-keyword">return</span> { handler: props.handler, path: props.path, method: <span class="hljs-string">'get'</span> }; 
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Element === Router) {
    <span class="hljs-keyword">const</span> router = express.Router();
    <span class="hljs-comment">// Let the children decide what `method`, `path`, and `handler`</span>
    <span class="hljs-comment">// to use.</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> children) {
      router[child.method](child.path, child.handler);
    }
    <span class="hljs-keyword">return</span> { method: <span class="hljs-string">'use'</span>, path: props.path, handler: router }; 
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStatus</span>(<span class="hljs-params">req, res</span>) </span>{
  res.send(<span class="hljs-string">'OK'</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getVersion</span>(<span class="hljs-params">req, res</span>) </span>{
  res.json({ version: <span class="hljs-string">'1.0.0'</span> });
}
</code></pre>
<h2 id="mongoose-schema-definitions">Mongoose Schema Definitions</h2>
<p>You can use JSX anywhere you have complex nested objects. So how
about <a href="https://mongoosejs.com/docs/guide.html">Mongoose schemas</a>?</p>
<p>Below is a Mongoose schema with several nested properties and options:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> mongoose.Schema({
  email: {
    type: <span class="hljs-built_in">String</span>,
    required: <span class="hljs-literal">true</span>
  },
  job: {
    company: <span class="hljs-built_in">String</span>,
    title: <span class="hljs-built_in">String</span>
  },
  address: <span class="hljs-keyword">new</span> mongoose.Schema({
    street: {
      type: <span class="hljs-built_in">String</span>,
      required: <span class="hljs-literal">true</span>
    },
    city: {
      type: <span class="hljs-built_in">String</span>,
      required: <span class="hljs-literal">true</span>,
      trim: <span class="hljs-literal">true</span>
    },
    state: {
      type: <span class="hljs-built_in">String</span>,
      required: <span class="hljs-literal">true</span>,
      enum: [<span class="hljs-string">'CA'</span>, <span class="hljs-string">'NJ'</span>, <span class="hljs-string">'NY'</span>, <span class="hljs-string">'FL'</span>]
    }
  })
}, { id: <span class="hljs-literal">false</span>, bufferCommands: <span class="hljs-literal">false</span> });</code></pre>
<p>With a little pragma magic, we can make the below JSX equivalent to
the above schema definition:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> schema = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Schema</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{false}</span> <span class="hljs-attr">bufferCommands</span>=<span class="hljs-string">{false}</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"String"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Nested</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"job"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"company"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"String"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"String"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Nested</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Schema</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"street"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"city"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">trim</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"state"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">enum</span>=<span class="hljs-string">{['CA',</span> '<span class="hljs-attr">NJ</span>', '<span class="hljs-attr">NY</span>', '<span class="hljs-attr">FL</span>']}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Schema</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Schema</span>&gt;</span>;</span></code></pre>
<p>Below is the full code:</p>
<pre><code class="language-javascript"><span class="hljs-comment">/** @jsx pragma */</span>

<span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);

<span class="hljs-keyword">const</span> Schema = mongoose.Schema;
<span class="hljs-keyword">const</span> SchemaType = mongoose.SchemaType;

<span class="hljs-comment">// No-op since Mongoose doesn't have a "nested" SchemaType currently</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Nested</span>(<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-keyword">const</span> schema = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Schema</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{false}</span> <span class="hljs-attr">bufferCommands</span>=<span class="hljs-string">{false}</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"String"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Nested</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"job"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"company"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"String"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"String"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Nested</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Schema</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"street"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"city"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">trim</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">SchemaType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"state"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">enum</span>=<span class="hljs-string">{['CA',</span> '<span class="hljs-attr">NJ</span>', '<span class="hljs-attr">NY</span>', '<span class="hljs-attr">FL</span>']}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SchemaType</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Schema</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Schema</span>&gt;</span>;</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pragma</span>(<span class="hljs-params">Element, props</span>) </span>{
  <span class="hljs-keyword">const</span> children = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);
  <span class="hljs-keyword">if</span> (Element === Schema) {
    <span class="hljs-keyword">if</span> (props != <span class="hljs-literal">null</span> &amp;&amp; props.name != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> { [props.name]: <span class="hljs-keyword">new</span> Schema(children, props) };
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Schema(children, props);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Element === SchemaType) {
    <span class="hljs-keyword">return</span> { [props.name]: props };
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Element === Nested) {
    <span class="hljs-keyword">const</span> copy = { ...props };
    <span class="hljs-keyword">delete</span> copy.name;
       <span class="hljs-keyword">return</span> { [props.name]: copy };
  }
}</code></pre>
</div><div style="color: #666666; border-top: 1px dashed #666666; margin: 25px; text-align: center; padding-top: 10px"><em>Found a typo or error? Open up a pull request! This post is
available as markdown on&nbsp;<a href="https://github.com/vkarpov15/thecodebarbarian.com/blob/master/lib/posts/#{post.src.substr('./lib/posts/'.length)}">Github</a></em></div><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'codebarbarian'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></div></div><div style="padding-bottom: 100px">&nbsp;</div><script type="text/javascript">var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://g0a3nbw0xa.execute-api.us-east-1.amazonaws.com/prod/track', true);
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.onreadystatechange = function() {};
xhr.send(JSON.stringify({
  path: window.location.pathname,
  hostname: window.location.hostname
}));</script><link rel="stylesheet" href="/style/inlinecpc.css"></body></html>