<!DOCTYPE html><html><head><script type="text/javascript">var _sf_startpt=(new Date()).getTime()
</script><title>The 80/20 Guide to Express Error Handling | www.thecodebarbarian.com</title><meta name="viewport" content="width=device-width, initial-scale=1"><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,600,700" rel="stylesheet" type="text/css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"><link href="/style/style.css" rel="stylesheet" type="text/css"><link href="/style/github.css" rel="stylesheet" type="text/css"><script href="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script><script href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script><script href="/javascript/sidebar.js" type="text/javascript"></script><meta property="og:title" content="The 80/20 Guide to Express Error Handling"><meta property="og:url" content="http://www.thecodebarbarian.com/80-20-guide-to-express-error-handling"><meta property="og:image" content="http://i.imgur.com/xmiL2zE.jpg"><meta property="og:site_name" content="The Code Barbarian"><meta property="description" content="Express supports error handling middleware, which gets called when an error occurs in one of your routes. Here's what you need to know."></head><body><div class="navbar social-links hidden-sm hidden-xs"><div class="container"><ul class="nav navbar-nav navbar-right"><li><a href="http://www.twitter.com/code_barbarian">twitter</a></li><li><a href="http://www.github.com/vkarpov15">github</a></li><li><a href="http://thecodebarbarian.com/feed.xml">rss</a></li><li><a href="/recommendations">recommendations</a></li></ul></div></div><div class="navbar" id="nav"><div class="container"><div class="navbar-header"><a class="navbar-brand big-brand" href="http://thecodebarbarian.com"><img class="logo" src="/images/Barbarian_Head.png"><span class="site-name">The Code Barbarian</span></a></div><div class="navbar-right collapse navbar-collapse" id="home-nav-mobile"><ul class="nav navbar-nav"><li><a href="/tag/mongodb.html">MongoDB</a></li><li><a href="/tag/nodejs.html">NodeJS</a></li><li><a href="/tag/asyncawait.html">Async/Await</a></li><li><a href="/tag/vue.html">Vue</a></li><li class="hidden-md hidden-lg"><a href="#">@code_barbarian</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Github</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Facebook</a></li></ul></div></div></div><div class="container-fluid"><div class="col-lg-3 col-lg-offset-9 right-bar" id="desktop-right-bar"><div class="right-bar-content-slider pull-right"><div class="row recent-posts right-bar-group"><div class="col-lg-12 articles"><p class="right-bar-label">Most Popular Articles</p><ul class="list-unstyled"><li class="right-bar-li"><a href="/common-async-await-design-patterns-in-node.js.html">Common Async/Await Design Patterns in Node.js</a></li><li class="right-bar-li"><a href="/unhandled-promise-rejections-in-node.js.html">Unhandled Promise Rejections in Node.js</a></li><li class="right-bar-li"><a href="/using-async-await-with-mocha-express-and-mongoose">Using Async/Await with Mocha, Express, and Mongoose</a></li><li class="right-bar-li"><a href="/write-your-own-node-js-promise-library-from-scratch.html">Write Your Own Node.js Promise Library from Scratch</a></li><li class="right-bar-li"><a href="/80-20-guide-to-express-error-handling">The 80/20 Guide to Express Error Handling</a></li></ul></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12 books"><p class="right-bar-label">Ebooks<div><a href="http://asyncawait.net/?utm_source=thecodebarbarian&amp;utm_campaign=sidebar"><img src="/images/verticalbanner.png"></a></div><div><a href="http://es2015generators.com"><img src="https://i.imgur.com/xvGNKlr.png"><p><i>The 80/20 Guide to ES2015 Generators</i></p></a></div><div><script type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&amp;serve=C6AILKT&amp;placement=thecodebarbariancom" id="_carbonads_js"></script></div></p></div></div></div></div></div><div class="container-fluid hidden-sm hidden-md hidden-lg" id="mobile-sharing-options"><div class="row"><div class="col-lg-12"><style>#home-nav-mobile {
  float: left !important;
  margin-left: 215px !important;
}
</style><div class="post-sharing-options"><div class="row"><div class="col-xs-3 twitter-share sharing-option"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter"></i></a></div><div class="col-xs-3 facebook-share sharing-option"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook"></i></a></div><div class="col-xs-3 google-share sharing-option"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus"></i></a></div><div class="col-xs-3 comment sharing-option"><a class="social" href="#disqus_thread"><i class="fa fa-comment"></i></a></div></div></div></div></div></div><div class="post-sharing-options hidden-xs pull-left" id="desktop-sharing-options"><ul class="list-unstyled"><li class="twitter-share"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter sharing-option"></i></a></li><li class="facebook-share"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook sharing-option"></i></a></li><li class="google-share"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus sharing-option"></i></a></li></ul></div><div class="container"><div class="col-lg-9 post-text"><div class="row"><div class="title-byline-container"><h1 class="post-title">The 80/20 Guide to Express Error Handling</h1><div class="credits"><span class="byline">by Valeri Karpov</span><span class="byhandle"><a href="http://www.twitter.com/code_barbarian">@code_barbarian</a></span><span class="bydate">August 04, 2017</span></div></div></div><script type="text/javascript" src="/js/native.js"></script><div><script>
  _native.init("CK7DT53N",{
    targetClass: 'native-inline'
  });
</script>

<div class="native-inline">
  <a href="#native_link#"><span class="sponsor">Sponsor</span> #native_company# - #native_desc#</a>
</div>
</div><div class="post-body-text-container"><p><a href="http://expressjs.com/en/guide/error-handling.html">Express&#39; error handling middleware</a> is a powerful tool for consolidating your HTTP error response logic. Odds are, if you&#39;ve written Express code you&#39;ve written code that looks like what you see below.</p>
<pre><code class="language-javascript">app.get(<span class="hljs-string">'/User'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-keyword">let</span> users;
  <span class="hljs-keyword">try</span> {
    users = <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'User'</span>).find().toArray();
  } <span class="hljs-keyword">catch</span> (error) {
    res.status(<span class="hljs-number">500</span>).json({ error: error.toString() });
  }
  res.json({ users });
});</code></pre>
<p>This pattern works well if you have one or two endpoints, but if you&#39;re maintaining dozens you&#39;re going to quickly lose your mind. Let&#39;s say you&#39;ve decided HTTP response code 503 is more appropriate than HTTP 500, you&#39;re going to have to change that for every single endpoint. How about adding stack traces to the error response in your dev environment? And do you really want to add a <code>try/catch</code> around every single HTTP and database call in your codebase? Sure that&#39;s the &quot;responsible&quot; and &quot;disciplined&quot; thing to do, but in programming discipline doesn&#39;t scale very well. With error handling middleware, you can do better.</p>
<h2 id="defining-error-handling-middleware">Defining Error Handling Middleware</h2>
<p>Express middleware is broken up into different types based on the number of arguments your middleware function takes. A middleware function that takes 4 arguments is classified as &quot;error handling middleware&quot;, and will only get called if an error occurs.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();

app.get(<span class="hljs-string">'*'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
  <span class="hljs-comment">// This middleware throws an error, so Express will go straight to</span>
  <span class="hljs-comment">// the next error handler</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'woops'</span>);
});

app.get(<span class="hljs-string">'*'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
  <span class="hljs-comment">// This middleware is not an error handler (only 3 arguments),</span>
  <span class="hljs-comment">// Express will skip it because there was an error in the previous</span>
  <span class="hljs-comment">// middleware</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this will not print'</span>);
});

app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, req, res, next</span>) </span>{
  <span class="hljs-comment">// Any request to this server will get here, and will send an HTTP</span>
  <span class="hljs-comment">// response with the error message 'woops'</span>
  res.json({ message: error.message });
});

app.listen(<span class="hljs-number">3000</span>);</code></pre>
<p>There are 2 ways to report an error in middleware to Express. The first,
as you saw above, is to throw an exception in the same tick. Because of
the async nature of JavaScript, this isn&#39;t very useful. If you throw
an error asynchronously, you&#39;ll just crash the server.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();

app.get(<span class="hljs-string">'*'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
  <span class="hljs-comment">// Will crash the server on every HTTP request</span>
  setImmediate(() =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'woops'</span>); });
});

app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, req, res, next</span>) </span>{
  <span class="hljs-comment">// Won't get here, because Express doesn't catch the above error</span>
  res.json({ message: error.message });
});

app.listen(<span class="hljs-number">3000</span>);</code></pre>
<p>The only way to report errors to Express for use with error handlers is
using the third argument to conventional middleware, the <code>next()</code> function. Your normal route handlers (like <code>app.get(&#39;/User&#39;, function(req, res) {})</code>) can also take a <code>next()</code> function as an argument.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();

app.get(<span class="hljs-string">'*'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
  <span class="hljs-comment">// Reporting async errors *must* go through `next()`</span>
  setImmediate(() =&gt; { next(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'woops'</span>)); });
});

app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, req, res, next</span>) </span>{
  <span class="hljs-comment">// Will get here</span>
  res.json({ message: error.message });
});

app.listen(<span class="hljs-number">3000</span>);</code></pre>
<p>Remember that Express middleware executes <strong>in order</strong>. You should define error handlers <strong>last</strong>, after all other middleware. Otherwise, your error handler won&#39;t get called:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();

app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, req, res, next</span>) </span>{
  <span class="hljs-comment">// Will **not** get called. You'll get Express' default error</span>
  <span class="hljs-comment">// handler, which returns `error.toString()` in the error body</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'will not print'</span>);
  res.json({ message: error.message });
});

app.get(<span class="hljs-string">'*'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
  setImmediate(() =&gt; { next(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'woops'</span>)); });
});

app.listen(<span class="hljs-number">3000</span>);</code></pre>
<h2 id="use-with-asyncawait">Use With Async/Await</h2>
<p>Cumbersome integration with promises is where the cracks start to show in Express&#39; API. Express was mostly written 2011-2014, before ES6, and it still lacks a good answer for how to handle the <a href="http://thecodebarbarian.com/80-20-guide-to-async-await-in-node.js">async/await keywords</a>. For example, the below server will never successfully send an HTTP response, because <a href="http://thecodebarbarian.com/unhandled-promise-rejections-in-node.js">the promise rejection will never get handled</a>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();

app.get(<span class="hljs-string">'*'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-comment">// Reporting async errors *must* go through `next()`</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
    setImmediate(() =&gt; reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'woops'</span>)))
  })
});

app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, req, res, next</span>) </span>{
  <span class="hljs-comment">// Will **not** get called. You'll get Express' default error</span>
  <span class="hljs-comment">// handler, which returns `error.toString()` in the error body</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'will not print'</span>);
  res.json({ message: error.message });
});

app.listen(<span class="hljs-number">3000</span>);</code></pre>
<p>However, with a little helper function you can tie async/await errors in with Express error handling middleware. Remember that <code>async</code> functions return promises, so you need to make sure to <code>.catch()</code> any errors and pass them to <code>next()</code>:</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapAsync</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
    <span class="hljs-comment">// Make sure to `.catch()` any errors and pass them along to the `next()`</span>
    <span class="hljs-comment">// middleware in the chain, in this case the error handler.</span>
    fn(req, res, next).catch(next);
  };
}</code></pre>
<p>If you make sure to call <code>wrapAsync()</code> on every async middleware function, any async exceptions will end up in your Express error handlers:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();

app.get(<span class="hljs-string">'*'</span>, wrapAsync(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), <span class="hljs-number">50</span>));
  <span class="hljs-comment">// Async error!</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'woops'</span>);
}));

app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, req, res, next</span>) </span>{
  <span class="hljs-comment">// Gets called because of `wrapAsync()`</span>
  res.json({ message: error.message });
});

app.listen(<span class="hljs-number">3000</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapAsync</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
    <span class="hljs-comment">// Make sure to `.catch()` any errors and pass them along to the `next()`</span>
    <span class="hljs-comment">// middleware in the chain, in this case the error handler.</span>
    fn(req, res, next).catch(next);
  };
}</code></pre>
<p>Now this is where the power of error handling middleware really comes in. In other languages (I&#39;m looking at you, <a href="https://blog.golang.org/error-handling-and-go">Golang</a> ) you&#39;re essentially required to check for errors on every I/O operation and manually bubble them up. I&#39;m sure this tedious exercise builds character, but in practice it just makes code cumbersome and hard to refactor.</p>
<p>With <code>wrapAsync()</code>, every async error ends up in an error handling middleware. You can define cross-cutting rules like &quot;every assertion error triggers an HTTP 400&quot; and &quot;every database error should be an HTTP 503&quot;:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { AssertionError } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);
<span class="hljs-keyword">const</span> { MongoError } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>);

app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAssertionError</span>(<span class="hljs-params">error, req, res, next</span>) </span>{
  <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> AssertionError) {
    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">400</span>).json({
      type: <span class="hljs-string">'AssertionError'</span>,
      message: error.message
    });
  }
  next(error);
});

app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleDatabaseError</span>(<span class="hljs-params">error, req, res, next</span>) </span>{
  <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> MongoError) {
    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">503</span>).json({
      type: <span class="hljs-string">'MongoError'</span>,
      message: error.message
    });
  }
  next(error);
});</code></pre>
<p>Instead of defining error handling on a one-off basis in your individual routes, or, worse yet, in a giant <code>handleError()</code> God function, you can define distinct handlers that each handle a certain error condition. You can define error handlers for what happens when your API can&#39;t connect to your database, when the user&#39;s request didn&#39;t match your schema, and when an external API failed.</p>
<h2 id="moving-on">Moving On</h2>
<p>Express error handling middleware lets you handle errors in a way that maximizes separation of concerns. You don&#39;t need to handle errors in your business logic - if you use async/await, you don&#39;t even need <code>try/catch</code>. These errors will bubble to your error handlers, which can then decide how to respond to the request. Make sure you take advantage of this powerful feature in your next Express app!</p>
<p><em>If you&#39;re stuck on Node 6 but want to use async/await, check out my ebook on <a href="http://npmjs.org/package/co">co</a>, <a href="http://es2015generators.com/">The 80/20 Guide to ES2015 Generators</a>. Co/yield is essentially a drop-in replacement for async/await that works in Node.js &gt;= 4.0.0 with no flags. The two paradigms, async/await and co/yield, are interchangeable except for some advanced use cases, so check out the ebook even if you&#39;re more interested in async/await.</em></p>
</div><div style="color: #666666; border-top: 1px dashed #666666; margin: 25px; text-align: center; padding-top: 10px"><em>Found a typo or error? Open up a pull request! This post is
available as markdown on&nbsp;<a href="https://github.com/vkarpov15/thecodebarbarian.com/blob/master/lib/posts/#{post.src.substr('./lib/posts/'.length)}">Github</a></em></div><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'codebarbarian'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></div></div><div style="padding-bottom: 100px">&nbsp;</div><script type="text/javascript">var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://g0a3nbw0xa.execute-api.us-east-1.amazonaws.com/prod/track', true);
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.onreadystatechange = function() {};
xhr.send(JSON.stringify({
  path: window.location.pathname,
  hostname: window.location.hostname
}));</script><link rel="stylesheet" href="/style/inlinecpc.css"></body></html>