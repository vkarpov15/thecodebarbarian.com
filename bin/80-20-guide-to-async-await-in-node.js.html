<!DOCTYPE html><html><head><script type="text/javascript">var _sf_startpt=(new Date()).getTime()
</script><title>The 80/20 Guide to Async/Await in Node.js | www.thecodebarbarian.com</title><meta name="viewport" content="width=device-width, initial-scale=1"><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,600,700" rel="stylesheet" type="text/css"><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"><link href="/style/style.css" rel="stylesheet" type="text/css"><link href="/style/github.css" rel="stylesheet" type="text/css"><script href="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script><script href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script><script href="/javascript/sidebar.js" type="text/javascript"></script><meta property="og:title" content="The 80/20 Guide to Async/Await in Node.js"><meta property="og:url" content="http://www.thecodebarbarian.com/80-20-guide-to-async-await-in-node.js"><meta property="og:image" content="http://i.imgur.com/9D2tvfU.png"><meta property="og:site_name" content="The Code Barbarian"><meta property="description" content="Arguably the biggest new feature in [Node.js 7.6.0](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V7.md#7.6.0) is that the [much awaited async function keyword is now available without a flag](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function). [Callback hell](http://thecodebarbarian.com/2015/03/20/callback-hell-is-a-myth) and promise hell are now in the past. But, like [Uncle Ben always reminded us](https://en.wikipedia.org/wiki/Uncle_Ben#.22With_great_power_comes_great_responsibility.22), with great power comes great responsibility, and async/await gives you a lot of new and exciting ways to shoot yourself in the foot. You still need to handle errors and be aware of the async nature of your code, otherwise you'll inevitably be complaining about &quot;async/await hell&quot; in 6 months."></head><body><div class="navbar social-links hidden-sm hidden-xs"><div class="container"><ul class="nav navbar-nav navbar-right"><li><a href="http://www.twitter.com/code_barbarian">twitter</a></li><li><a href="http://www.github.com/vkarpov15">github</a></li><li><a href="http://thecodebarbarian.com/feed.xml">rss</a></li><li><a href="/recommendations">recommendations</a></li></ul></div></div><div class="navbar" id="nav"><div class="container"><div class="navbar-header"><a class="navbar-brand big-brand" href="http://thecodebarbarian.com"><img class="logo" src="/images/Barbarian_Head.png"><span class="site-name">The Code Barbarian</span></a></div><div class="navbar-right collapse navbar-collapse" id="home-nav-mobile"><ul class="nav navbar-nav"><li><a href="/tag/mongodb.html">MongoDB</a></li><li><a href="/tag/nodejs.html">NodeJS</a></li><li><a href="/tag/asyncawait.html">Async/Await</a></li><li><a href="/tag/vue.html">Vue</a></li><li class="hidden-md hidden-lg"><a href="#">@code_barbarian</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Github</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Facebook</a></li></ul></div></div></div><div class="container-fluid"><div class="col-lg-3 col-lg-offset-9 right-bar" id="desktop-right-bar"><div class="right-bar-content-slider pull-right"><div class="row recent-posts right-bar-group"><div class="col-lg-12 articles"><p class="right-bar-label">Most Popular Articles</p><ul class="list-unstyled"><li class="right-bar-li"><a href="/common-async-await-design-patterns-in-node.js.html">Common Async/Await Design Patterns in Node.js</a></li><li class="right-bar-li"><a href="/unhandled-promise-rejections-in-node.js.html">Unhandled Promise Rejections in Node.js</a></li><li class="right-bar-li"><a href="/using-async-await-with-mocha-express-and-mongoose">Using Async/Await with Mocha, Express, and Mongoose</a></li><li class="right-bar-li"><a href="/write-your-own-node-js-promise-library-from-scratch.html">Write Your Own Node.js Promise Library from Scratch</a></li><li class="right-bar-li"><a href="/80-20-guide-to-express-error-handling">The 80/20 Guide to Express Error Handling</a></li></ul></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12 books"><p class="right-bar-label">Ebooks<div><a href="http://asyncawait.net/?utm_source=thecodebarbarian&amp;utm_campaign=sidebar"><img src="/images/verticalbanner.png"></a></div><div><a href="http://es2015generators.com"><img src="https://i.imgur.com/xvGNKlr.png"><p><i>The 80/20 Guide to ES2015 Generators</i></p></a></div><div><script type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&amp;serve=C6AILKT&amp;placement=thecodebarbariancom" id="_carbonads_js"></script></div></p></div></div></div></div></div><div class="container-fluid hidden-sm hidden-md hidden-lg" id="mobile-sharing-options"><div class="row"><div class="col-lg-12"><style>#home-nav-mobile {
  float: left !important;
  margin-left: 215px !important;
}
</style><div class="post-sharing-options"><div class="row"><div class="col-xs-3 twitter-share sharing-option"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter"></i></a></div><div class="col-xs-3 facebook-share sharing-option"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook"></i></a></div><div class="col-xs-3 google-share sharing-option"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus"></i></a></div><div class="col-xs-3 comment sharing-option"><a class="social" href="#disqus_thread"><i class="fa fa-comment"></i></a></div></div></div></div></div></div><div class="post-sharing-options hidden-xs pull-left" id="desktop-sharing-options"><ul class="list-unstyled"><li class="twitter-share"><a class="social" href="https://twitter.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}&amp;via=code_barbarian"><i class="fa fa-twitter sharing-option"></i></a></li><li class="facebook-share"><a class="social" href="https://www.facebook.com/sharer/sharer.php?u=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-facebook sharing-option"></i></a></li><li class="google-share"><a class="social" href="https://plus.google.com/share?url=#{encodeURIComponent('http://www.thecodebarbarian.com/' + post.dest.directory.substr('./bin'.length) + '/' + post.dest.name)}"><i class="fa fa-google-plus sharing-option"></i></a></li></ul></div><div class="container"><div class="col-lg-9 post-text"><div class="row"><div class="title-byline-container"><h1 class="post-title">The 80/20 Guide to Async/Await in Node.js</h1><div class="credits"><span class="byline">by Valeri Karpov</span><span class="byhandle"><a href="http://www.twitter.com/code_barbarian">@code_barbarian</a></span><span class="bydate">March 08, 2017</span></div></div></div><script type="text/javascript" src="/js/native.js"></script><div><script>
  _native.init("CK7DT53N",{
    targetClass: 'native-inline'
  });
</script>

<div class="native-inline">
  <a href="#native_link#"><span class="sponsor">Sponsor</span> #native_company# - #native_desc#</a>
</div>
</div><div class="post-body-text-container"><p>Arguably the biggest new feature in <a href="https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V7.md#7.6.0">Node.js 7.6.0</a> is that the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">much awaited async function keyword is now available without a flag</a>. <a href="http://thecodebarbarian.com/2015/03/20/callback-hell-is-a-myth">Callback hell</a> and promise hell are now in the past. But, like <a href="https://en.wikipedia.org/wiki/Uncle_Ben#.22With_great_power_comes_great_responsibility.22">Uncle Ben always reminded us</a>, with great power comes great responsibility, and async/await gives you a lot of new and exciting ways to shoot yourself in the foot. You still need to handle errors and be aware of the async nature of your code, otherwise you&#39;ll inevitably be complaining about &quot;async/await hell&quot; in 6 months.</p>
<p><em>All code in this article was tested on node.js 7.6.0. It will not work on earlier versions of node. <a href="https://nodejs.org/en/blog/release/v7.0.0/">Node.js 7.x</a> is an odd-numbered Node.js release, which means it is scheduled to be deprecated in June 2017, so I wouldn&#39;t recommend using it in production.</em></p>
<h2 id="hello-world">Hello, World</h2>
<p>Here&#39;s a &quot;Hello, World&quot; example of using async/await:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; setTimeout(() =&gt; resolve(), <span class="hljs-number">1000</span>));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
}

test();</code></pre>
<p>You can run this node script like any other, without any transpilers, and it
will print out &quot;Hello, World!&quot; after approximately 1 second. This is how
you can implement <a href="https://masteringjs.io/tutorials/fundamentals/sleep">JavaScript sleep</a>
with async/await.</p>
<pre><code class="language-javascript">$ ~<span class="hljs-regexp">/Workspace/</span>node-v7<span class="hljs-number">.6</span><span class="hljs-number">.0</span>-linux-x64/bin/node <span class="hljs-keyword">async</span>.js
Hello, World!
$
$ time ~<span class="hljs-regexp">/Workspace/</span>node-v7<span class="hljs-number">.6</span><span class="hljs-number">.0</span>-linux-x64/bin/node <span class="hljs-keyword">async</span>.js
Hello, World!

real    <span class="hljs-number">0</span>m1<span class="hljs-number">.121</span>s
user    <span class="hljs-number">0</span>m0<span class="hljs-number">.115</span>s
sys    <span class="hljs-number">0</span>m0<span class="hljs-number">.008</span>s
$</code></pre>
<p>Async functions are based entirely on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promises</a>. You should always <code>await</code> on a promise. Using <code>await</code> on a non-promise won&#39;t do anything:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Works, just doesn't do anything useful</span>
  <span class="hljs-keyword">await</span> <span class="hljs-number">5</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
}

test();</code></pre>
<p>You don&#39;t need to use native Node.js promises with <code>await</code>. <a href="https://www.npmjs.com/package/bluebird">Bluebird</a> or any other promise lib should work. In general, using <code>await</code> with any object that has a <code>then()</code> function will work:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// This object is a "thenable". It's a promise by the letter of the law,</span>
  <span class="hljs-comment">// but not the spirit of the law.</span>
  <span class="hljs-keyword">await</span> { then: resolve =&gt; setTimeout(() =&gt; resolve(), <span class="hljs-number">1000</span>) };
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
}

test();</code></pre>
<p>There is one major restriction for using <code>await</code>: you <strong>must</strong> use <code>await</code> within a function that&#39;s declared <code>async</code>. The below code will result in a <code>SyntaxError</code>.</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), <span class="hljs-number">1000</span>));
  <span class="hljs-comment">// SyntaxError: Unexpected identifier</span>
  <span class="hljs-keyword">await</span> p;
}

test();</code></pre>
<p>Furthermore, <code>await</code> must <strong>not</strong> be in a closure embedded in an async function, unless the closure is also an async function. The below code also results in a <code>SyntaxError</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'test'</span>);
  assert.doesNotThrow(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// SyntaxError: Unexpected identifier</span>
    <span class="hljs-keyword">await</span> p;
  });
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, world!'</span>);
}

test();</code></pre>
<p>Another important detail to remember about <code>async</code> functions is that <code>async</code> functions return promises:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; setTimeout(() =&gt; resolve(), <span class="hljs-number">1000</span>));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
}

<span class="hljs-comment">// Prints "Promise { &lt;pending&gt; }"</span>
<span class="hljs-built_in">console</span>.log(test());</code></pre>
<p>This means that you can <code>await</code> on the result of an <code>async</code> function.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), ms));
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Since `wait()` is marked `async`, the return value is a promise, so</span>
  <span class="hljs-comment">// you can `await`</span>
  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1000</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
}

test();</code></pre>
<h2 id="return-values-and-exceptions">Return Values and Exceptions</h2>
<p>A promise can either <em>resolve</em> to a value or <em>reject</em> with an error. Async/await lets you handle these cases with synchronous operators: assignment for resolved values, and <code>try/catch</code> for exceptions. The return value of <code>await</code> is the value that the promise resolves to:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; {
    <span class="hljs-comment">// This promise resolves to "Hello, World!" after ~ 1sec</span>
    setTimeout(() =&gt; resolve(<span class="hljs-string">'Hello, World!'</span>), <span class="hljs-number">1000</span>);
  });
  <span class="hljs-comment">// Prints "Hello, World!". `res` is equal to the value the promise resolved to</span>
  <span class="hljs-built_in">console</span>.log(res);
}

test();</code></pre>
<p>In an async function, you can use <code>try/catch</code> to catch promise rejections. In other words, asynchronous promise rejections behave like synchronous errors:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
      setTimeout(() =&gt; reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Woops!'</span>)), <span class="hljs-number">1000</span>);
    });
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Prints "Caught Woops!"</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Caught'</span>, error.message);
  }
}

test();</code></pre>
<p>Using <code>try/catch</code> as an error handling mechanism is powerful because it enables you to handle synchronous errors and asynchronous errors with a single syntax. In callback land you&#39;d often have to wrap your async calls in a <code>try/catch</code> as well as handling the <code>error</code> callback parameter.</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bad</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'bad'</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bad2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(() =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'bad2'</span>); });
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> bad();
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'caught'</span>, error.message);
  }

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> bad2();
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'caught'</span>, error.message);
  }
}

test();</code></pre>
<h2 id="loops-and-conditionals">Loops and Conditionals</h2>
<p>The number one killer feature of async/await is that you can write async code using <code>if</code> statements, <code>for</code> loops, and all the other synchronous constructs that you had to swear off of when using callbacks. You don&#39;t need any <a href="http://npmjs.org/package/async">flow control libraries</a> with async/await, you just use conditionals and loops. Here&#39;s an example using a <code>for</code> loop:</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), ms));
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
    <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1000</span>);
    <span class="hljs-comment">// Prints out "Hello, World!" once per second and then exits</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
  }
}

test();</code></pre>
<p>And an example using an <code>if</code> statement:</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), ms));
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">5</span>) {
      <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1000</span>);
    }
    <span class="hljs-comment">// Prints out "Hello, World!" once per second 5 times, then prints it 5 times immediately</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
  }
}

test();</code></pre>
<h2 id="remember-its-asynchronous">Remember It&#39;s Asynchronous</h2>
<p>One cute JavaScript interview question I used to ask was what would the below code print out?</p>
<pre><code class="language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) {
  <span class="hljs-comment">// Actually prints out "5" 5 times.</span>
  <span class="hljs-comment">// But if you use `let` above, it'll print out 0-4</span>
  setTimeout(() =&gt; <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>);
}

<span class="hljs-comment">// This will print *before* the 5's</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end'</span>);</code></pre>
<p>Asynchronous code is confusing, and async/await makes it easier to write asyncronous code but doesn&#39;t change the nature of asynchronous code. Just because <code>async</code> functions look synchronous doesn&#39;t mean they are:</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), ms));
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) {
    <span class="hljs-keyword">await</span> wait(ms);
    <span class="hljs-built_in">console</span>.log(ms * (i + <span class="hljs-number">1</span>));
  }
}

<span class="hljs-comment">// These two function calls will actually run in parallel</span>
test(<span class="hljs-number">70</span>);
test(<span class="hljs-number">130</span>);

<span class="hljs-comment">// Output</span>
<span class="hljs-number">70</span>
<span class="hljs-number">130</span>
<span class="hljs-number">140</span>
<span class="hljs-number">210</span>
<span class="hljs-number">260</span>
<span class="hljs-number">280</span>
<span class="hljs-number">350</span>
<span class="hljs-number">390</span>
<span class="hljs-number">520</span>
<span class="hljs-number">650</span></code></pre>
<h2 id="error-handling">Error Handling</h2>
<p>Remember that you can only use <code>await</code> within an <code>async</code> function, and <code>async</code> functions return promises. This means that somewhere in your code you&#39;re going to have to handle errors. Async/await gives you a powerful mechanism for aggregating errors: all errors that occur in the async function, synchronous or asynchronous, are bubbled up as a promise rejection. However, it&#39;s up to you to handle the error. Here&#39;s <a href="https://medium.com/@yamalight/danger-of-using-async-await-in-es7-8006e3eb7efb#.9hi1z9gry">another interesting article on the topic of handling promise rejections with async/await</a>.</p>
<p>Let&#39;s say you want to use async/await with the <a href="http://npmjs.org/package/express">Express web framework</a>. The naive way of using async functions with Express works in the most basic case:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);

<span class="hljs-keyword">const</span> app = express();

app.get(<span class="hljs-string">'/'</span>, handler);

app.listen(<span class="hljs-number">3000</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-comment">// Will wait approximately 1 second before sending the result</span>
  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1000</span>);
  res.send(<span class="hljs-string">'Hello, world'</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), ms));
}</code></pre>
<p><a href="http://i.imgur.com/RmWWczB.png"><img src="http://i.imgur.com/RmWWczB.png"></a></p>
<p>So we&#39;re done, right? <strong>Wrong</strong>. What happens if you throw an exception in the <code>handler</code> function?</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);

<span class="hljs-keyword">const</span> app = express();

app.get(<span class="hljs-string">'/'</span>, handler);

app.listen(<span class="hljs-number">3000</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Hang!'</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(), ms));
}</code></pre>
<p>Express will hang forever, the server won&#39;t crash, and the only indication of an error would be an unhandled promise rejection warning.</p>
<pre><code>$ node async.js
(node:17661) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: Hang!
(node:17661) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</code></pre><p>Since <code>await</code> treats promise rejections as exceptions, unless you <code>try/catch</code> around <code>await</code> the rejection will cause the entire function to stop executing. The below <code>handler</code> function will also hang with an unhandled promise rejection warning.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Hang!'</span>)));
  res.send(<span class="hljs-string">'Hello, World!'</span>);
}</code></pre>
<img src="https://cdn.meme.am/cache/instances/folder898/500x/76013898.jpg">

<p>The single most important takeaway from this article is that <code>async</code> functions return a promise. Async/await gives you the ability to build sophisticated async logic with loops, conditionals, and <code>try/catch</code>, but in the end it packages all this logic into a single promise. If you see async/await code that doesn&#39;t include any <code>.catch()</code> calls, odds are that code is missing some error cases. Here&#39;s a better way of handling async functions with Express:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);

<span class="hljs-keyword">const</span> app = express();

app.get(<span class="hljs-string">'/'</span>, safeHandler(handler));

app.listen(<span class="hljs-number">3000</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeHandler</span>(<span class="hljs-params">handler</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
    handler(req, res).catch(error =&gt; res.status(<span class="hljs-number">500</span>).send(error.message));
  };
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Hang!'</span>)));
  res.send(<span class="hljs-string">'Hello, World!'</span>);
}</code></pre>
<p>The <code>safeHandler</code> function chains <code>.catch()</code> onto the promise that the async <code>handler</code> function returns. This ensures that your server sends an HTTP response, even if <code>handler</code> errors out. If calling <code>safeHandler</code> on every request handler seems cumbersome, there are numerous alternatives, like using <a href="http://thecodebarbarian.com/rest-apis-with-observables.html">observables</a> or <a href="http://thecodebarbarian.com/using-ramda-as-a-dependency-injector">ramda</a>.</p>
<h2 id="asyncawait-vs-coyield">Async/Await vs Co/Yield</h2>
<p>The <a href="https://www.npmjs.com/package/co">co</a> library uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">ES6 generators</a> to get functionality similar to async/await. For example, here&#39;s how the <code>safeHandler</code> code example would look with co/yield:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);

<span class="hljs-keyword">const</span> app = express();

app.get(<span class="hljs-string">'/'</span>, safeHandler(handler));

app.listen(<span class="hljs-number">3000</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeHandler</span>(<span class="hljs-params">handler</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
    handler(req, res).catch(error =&gt; res.status(<span class="hljs-number">500</span>).send(error.message));
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-keyword">return</span> co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Hang!'</span>)));
    res.send(<span class="hljs-string">'Hello, World!'</span>);
  });
}</code></pre>
<p>As a matter of fact, you can replace every <code>async function(params) {}</code> in this article with <code>function(params) { return co(function*() {}) }</code> and <code>await</code> with <code>yield</code> and all the examples will still work.</p>
<p>The upside of using co is that co works without any transpilation in Node.js 4.x and 6.x. The <a href="https://github.com/nodejs/LTS#lts-schedule">EOL of 4.x and 6.x</a> is in 2018 and 2019, respectively, so these releases are more stable than Node.js 7.x. Until Node.js 8 is released <a href="https://github.com/nodejs/node/issues/10117">(tentatively scheduled for April 2017)</a> there&#39;s no LTS version of Node.js that supports async/await without transpilers. Co also enjoys better browser support, and every transpiler for async/await that I know of compiles down to using generators. If you&#39;re interested in really mastering co and generators, check out my ebook, <a href="http://es2015generators.com">The 80/20 Guide to ES2015 Generators</a>, which walks you through writing your own co from scratch.</p>
<p>Async/await has numerous advantages, most notably readable stack traces. Let&#39;s compare the stack traces of using co vs using async/await with the Express example:</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-keyword">return</span> co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Hang!'</span>)));
    res.send(<span class="hljs-string">'Hello, World!'</span>);
  });
}

<span class="hljs-comment">// --- versus ---</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Hang!'</span>)));
  res.send(<span class="hljs-string">'Hello, World!'</span>);
}</code></pre>
<p>Async:</p>
<pre><code>$ node async.js
Error: Hang!
    at Promise (/home/val/async.js:16:49)
    at handler (/home/val/async.js:16:9)
    at /home/val/async.js:11:5
    at Layer.handle [as handle_request] (/home/val/node_modules/express/lib/router/layer.js:95:5)
    at next (/home/val/node_modules/express/lib/router/route.js:137:13)
    at Route.dispatch (/home/val/node_modules/express/lib/router/route.js:112:3)
    at Layer.handle [as handle_request] (/home/val/node_modules/express/lib/router/layer.js:95:5)
    at /home/val/node_modules/express/lib/router/index.js:281:22
    at Function.process_params (/home/val/node_modules/express/lib/router/index.js:335:12)
    at next (/home/val/node_modules/express/lib/router/index.js:275:10)</code></pre><p>Co:</p>
<pre><code>$ node async.js
Error: Hang!
    at Promise (/home/val/async.js:18:51)
    at /home/val/async.js:18:11
    at Generator.next (&lt;anonymous&gt;)
    at onFulfilled (/home/val/node_modules/co/index.js:65:19)
    at /home/val/node_modules/co/index.js:54:5
    at co (/home/val/node_modules/co/index.js:50:10)
    at handler (/home/val/async.js:17:10)
    at /home/val/async.js:12:5
    at Layer.handle [as handle_request] (/home/val/node_modules/express/lib/router/layer.js:95:5)
    at next (/home/val/node_modules/express/lib/router/route.js:137:13)</code></pre><p>So async/await has better stack traces and lets you construct promises using the built-in loops and conditionals that you already know, so download Node.js 7.6 and give it a shot!</p>
<p><em>Looking to become fluent in async/await? My new ebook, Mastering Async/Await, is designed to give you an integrated understanding of
async/await fundamentals and how async/await fits in the JavaScript ecosystem in a few hours. <a href="http://asyncawait.net/">Get your copy!</a></em></p>
<p><a href="http://asyncawait.net/?utm_source=thecodebarbarian&utm_campaign=trailingbanner" class="async-await-banner"><img src="/images/asyncawait.png"/></a></p>
</div><div style="color: #666666; border-top: 1px dashed #666666; margin: 25px; text-align: center; padding-top: 10px"><em>Found a typo or error? Open up a pull request! This post is
available as markdown on&nbsp;<a href="https://github.com/vkarpov15/thecodebarbarian.com/blob/master/lib/posts/#{post.src.substr('./lib/posts/'.length)}">Github</a></em></div><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'codebarbarian'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></div></div><div style="padding-bottom: 100px">&nbsp;</div><script type="text/javascript">var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://g0a3nbw0xa.execute-api.us-east-1.amazonaws.com/prod/track', true);
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.onreadystatechange = function() {};
xhr.send(JSON.stringify({
  path: window.location.pathname,
  hostname: window.location.hostname
}));</script><link rel="stylesheet" href="/style/inlinecpc.css"></body></html>