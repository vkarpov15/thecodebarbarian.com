<html><head><script type="text/javascript">var _sf_startpt=(new Date()).getTime()
</script><title>Single Link Clustering with Node.js | www.thecodebarbarian.com</title><meta name="viewport" content="width=device-width, initial-scale=1"/><link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet" type="text/css"/><link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet" type="text/css"/><link href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,600,700" rel="stylesheet" type="text/css"/><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet"/><link href="/style/style.css" rel="stylesheet" type="text/css"/><link href="/style/github.css" rel="stylesheet" type="text/css"/><script href="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script><script href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script><script href="/javascript/sidebar.js" type="text/javascript"></script><meta property="og:title" content="Single Link Clustering with Node.js"/><meta property="og:url" content="http://www.thecodebarbarian.com/single-link-clustering-with-node-js"/><meta property="og:image" content="https://i.imgur.com/NhVPj8B.png"/><meta property="og:site_name" content="The Code Barbarian"/></head><body><div class="navbar social-links hidden-sm hidden-xs"><div class="container"><ul class="nav navbar-nav navbar-right"><li><a href="http://www.twitter.com/code_barbarian">twitter</a></li><li><a href="http://www.github.com/vkarpov15">github</a></li><li><a href="http://thecodebarbarian.com/feed.xml">rss</a></li></ul></div></div><div id="nav" class="navbar"><div class="container"><div class="navbar-header"><a href="http://thecodebarbarian.com" class="navbar-brand big-brand"><img src="/images/Barbarian_Head.png" class="logo"/><span class="site-name">The Code Barbarian</span></a></div><div id="home-nav-mobile" class="navbar-right collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href="/tag/mongodb.html">MongoDB</a></li><li><a href="/tag/angularjs.html">AngularJS</a></li><li><a href="/tag/nodejs.html">NodeJS</a></li><li><a href="/tag/asyncawait.html">Async/Await</a></li><li class="hidden-md hidden-lg"><a href="#">@code_barbarian</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Github</a></li><li class="hidden-md hidden-lg"><a href="#">TCB Facebook</a></li></ul></div></div></div><div class="container-fluid"><div id="desktop-right-bar" class="col-lg-3 col-lg-offset-9 right-bar"><div class="right-bar-content-slider pull-right"><div class="row recent-posts right-bar-group"><div class="col-lg-12 articles"><p class="right-bar-label">Most Popular Articles</p><ul class="list-unstyled"><li class="right-bar-li"><a href="/common-async-await-design-patterns-in-node.js.html">Common Async/Await Design Patterns in Node.js</a></li><li class="right-bar-li"><a href="/unhandled-promise-rejections-in-node.js.html">Unhandled Promise Rejections in Node.js</a></li><li class="right-bar-li"><a href="/using-async-await-with-mocha-express-and-mongoose">Using Async/Await with Mocha, Express, and Mongoose</a></li><li class="right-bar-li"><a href="/write-your-own-node-js-promise-library-from-scratch.html">Write Your Own Node.js Promise Library from Scratch</a></li><li class="right-bar-li"><a href="/80-20-guide-to-express-error-handling">The 80/20 Guide to Express Error Handling</a></li></ul></div></div><div class="row recent-posts right-bar-group"><div class="col-lg-12 books"><p class="right-bar-label">Ebooks<div><a href="http://asyncawait.net"><img src="http://asyncawait.net/images/cover_400.png"/><p><i>Mastering Async/Await</i></p></a></div><div><a href="http://es2015generators.com"><img src="https://i.imgur.com/xvGNKlr.png"/><p><i>The 80/20 Guide to ES2015 Generators</i></p></a></div><div><script type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&amp;serve=C6AILKT&amp;placement=thecodebarbariancom" id="_carbonads_js"></script></div></p></div></div></div></div></div><div id="mobile-sharing-options" class="container-fluid hidden-sm hidden-md hidden-lg"><div class="row"><div class="col-lg-12"><style>#home-nav-mobile {
  float: left !important;
  margin-left: 215px !important;
}
</style><div class="post-sharing-options"><div class="row"><div class="col-xs-3 twitter-share sharing-option"><a href="https://twitter.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2Fsingle-link-clustering-with-node-js&amp;via=code_barbarian" class="social"><i class="fa fa-twitter"></i></a></div><div class="col-xs-3 facebook-share sharing-option"><a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2Fsingle-link-clustering-with-node-js" class="social"><i class="fa fa-facebook"></i></a></div><div class="col-xs-3 google-share sharing-option"><a href="https://plus.google.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2Fsingle-link-clustering-with-node-js" class="social"><i class="fa fa-google-plus"></i></a></div><div class="col-xs-3 comment sharing-option"><a href="#disqus_thread" class="social"><i class="fa fa-comment"></i></a></div></div></div></div></div></div><div id="desktop-sharing-options" class="post-sharing-options hidden-xs pull-left"><ul class="list-unstyled"><li class="twitter-share"><a href="https://twitter.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2Fsingle-link-clustering-with-node-js&amp;via=code_barbarian" class="social"><i class="fa fa-twitter sharing-option"></i></a></li><li class="facebook-share"><a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2Fsingle-link-clustering-with-node-js" class="social"><i class="fa fa-facebook sharing-option"></i></a></li><li class="google-share"><a href="https://plus.google.com/share?url=http%3A%2F%2Fwww.thecodebarbarian.com%2F%2Fsingle-link-clustering-with-node-js" class="social"><i class="fa fa-google-plus sharing-option"></i></a></li></ul></div><div class="container"><div class="col-lg-9 post-text"><div class="row"><div class="title-byline-container"><h1 class="post-title">Single Link Clustering with Node.js</h1><div class="credits"><span class="byline">by Valeri Karpov</span><span class="byhandle"><a href="http://www.twitter.com/code_barbarian">@code_barbarian</a></span><span class="bydate">March 16, 2018</span></div></div></div><div><script>
  _native.init("CK7DT53U",{
    targetClass: 'native-inline'
  });
</script>

<div class="native-inline">
  <a href="#native_link#"><span class="sponsor">Sponsor</span> #native_company# â€” #native_desc#</a>
</div>
</div><div class="post-body-text-container"><p><a href="https://en.wikipedia.org/wiki/Cluster_analysis">Clustering</a> is the general study
of grouping similar objects together. This definition is purposely very abstract,
because what the objects are and how you define the &quot;distance&quot; between two objects both make a huge
difference in the output, but the general algorithms remain similar in all cases.
There are numerous <a href="https://en.wikipedia.org/wiki/Cluster_analysis#Algorithms">clustering algorithms</a> with different properties and different performance characteristics, but in this article I&#39;ll talk about <a href="https://en.wikipedia.org/wiki/Single-linkage_clustering">single link clustering</a>, or <a href="https://www.cs.ucsb.edu/~veronika/MAE/SLINK_sibson.pdf">SLINK</a> for short. Single link is one of the simplest clustering algorithms: it starts out with N clusters consisting of one object each, and at each step merges the two &quot;closest&quot; clusters. Single link clustering is easy to implement and I often use it to gain insight into hard-to-grasp data sets.</p>
<h2 id="clustering-geospatial-coordinates">Clustering Geospatial Coordinates</h2>
<p>An easy way to visualize how clustering works is by clustering points on a map.
The <a href="https://www.npmjs.com/package/@turf/distance">distance metric</a> is pretty obvious and the correct answer is easy to see at a glance. For example, below
is a map of the approximate coordinates of 8 <a href="https://www.mongodb.com/office-locations">MongoDB offices</a>: 4 in North America, 2 in Europe, 1 in the Middle East, and 1 in Australia. Intuitively, if you were to
break these locations into 4 clusters based on distance, you&#39;d cluster them into Australia, Europe, Middle East, and Australia. Click the below map for an interactive view.</p>
<p><a href="http://bl.ocks.org/d/ac30ab73ea85135ca9aa065d72c474d7"><img src="https://i.imgur.com/aTPr4Yg.png"></a></p>
<p>First, let&#39;s set up this data in Node.js using some <a href="http://thecodebarbarian.com/wrangling-geojson-with-turf.html">Turf.js</a> helpers.
First, install Turf. Over the last year Turf has been going overboard on micro-modules, <a href="https://docs.npmjs.com/getting-started/scoped-packages">npm scoped packages</a>, and ES6 imports, even dropping support for <code>require()</code>, but the new cumbersome Turf workflow is not quite bad enough to consider forking, so please bear with me.</p>
<pre><code>npm install @turf/helpers @turf/distance @turf/centroid
</code></pre><pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { point } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@turf/helpers'</span>);
<span class="hljs-keyword">const</span> centroid = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@turf/centroid'</span>)[<span class="hljs-string">'default'</span>];
<span class="hljs-keyword">const</span> distance = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@turf/distance'</span>)[<span class="hljs-string">'default'</span>];

<span class="hljs-keyword">const</span> cities = [
  <span class="hljs-string">'New York'</span>,
  <span class="hljs-string">'Palo Alto'</span>,
  <span class="hljs-string">'Austin'</span>,
  <span class="hljs-string">'Los Angeles'</span>,
  <span class="hljs-string">'Dublin'</span>,
  <span class="hljs-string">'London'</span>,
  <span class="hljs-string">'Tel Aviv'</span>,
  <span class="hljs-string">'Sydney'</span>
];
<span class="hljs-keyword">const</span> points = [
  [<span class="hljs-number">-73.9895767</span>, <span class="hljs-number">40.7572784</span>], <span class="hljs-comment">// New York</span>
  [<span class="hljs-number">-122.1633558</span>, <span class="hljs-number">37.4419716</span>], <span class="hljs-comment">// Palo Alto</span>
  [<span class="hljs-number">-97.8063463</span>, <span class="hljs-number">30.2453212</span>], <span class="hljs-comment">// Austin</span>
  [<span class="hljs-number">-118.4674619</span>, <span class="hljs-number">34.1539733</span>], <span class="hljs-comment">// Los Angeles</span>
  [<span class="hljs-number">-6.2325547</span>, <span class="hljs-number">53.332175</span>], <span class="hljs-comment">// Dublin</span>
  [<span class="hljs-number">-0.1090697</span>, <span class="hljs-number">51.5065462</span>], <span class="hljs-comment">// London</span>
  [<span class="hljs-number">34.7915409</span>, <span class="hljs-number">32.1039053</span>], <span class="hljs-comment">// Tel Aviv</span>
  [<span class="hljs-number">151.2022304</span>, <span class="hljs-number">-33.878484</span>] <span class="hljs-comment">// Sydney</span>
].map((p, index) =&gt; {
  <span class="hljs-keyword">const</span> pt = point(p);
  pt.properties.name = cities[index];
  <span class="hljs-keyword">return</span> pt;
});
</code></pre>
<p>Now, the goal is to cluster these points using single link clustering. The general idea of the algorithm is this:</p>
<ul>
<li>Start out with 8 clusters, each with one location</li>
<li>Pick the two closest clusters. In this case, &quot;closest&quot; is defined by minimum distance between the center of all points in cluster 1 and the center of all points in cluster 2.</li>
<li>Repeat until there are 4 clusters left.</li>
</ul>
<p>Below is the actual implementation of the clustering algorithm:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create 8 clusters, each with one location. Each cluster has a</span>
<span class="hljs-comment">// center so we can compute the "distance" between two clusters</span>
<span class="hljs-comment">// by seeing how far apart their centers are.</span>
<span class="hljs-keyword">const</span> clusters = points.map(p =&gt; ({ locs: [p], center: p }));

<span class="hljs-keyword">while</span> (clusters.length &gt; <span class="hljs-number">4</span>) {
  <span class="hljs-comment">// Find two closest clusters</span>
  <span class="hljs-keyword">let</span> minClusterDistance = <span class="hljs-built_in">Number</span>.POSITIVE_INFINITY;
  <span class="hljs-keyword">let</span> minClusterI = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">let</span> minClusterJ = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; clusters.length; ++i) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; clusters.length; ++j) {
      <span class="hljs-keyword">const</span> dist = distance(clusters[i].center, clusters[j].center);
      <span class="hljs-keyword">if</span> (dist &lt; minClusterDistance) {
        minClusterDistance = dist;
        minClusterI = i;
        minClusterJ = j;
      }
    }
  }

  <span class="hljs-comment">// Combine the two closest clusters by adding minClusterJ into minClusterI...</span>
  clusters[minClusterI].locs = clusters[minClusterI].locs.concat(clusters[minClusterJ].locs);
  <span class="hljs-comment">// `centroid()` takes a GeoJSON FeatureCollection and spits out a point,</span>
  <span class="hljs-comment">// so need to convert our list of Features into a FeatureCollection</span>
  clusters[minClusterI].center = centroid({
    type: <span class="hljs-string">'FeatureCollection'</span>,
    features: clusters[minClusterI].locs
  });
  <span class="hljs-comment">// and removing minClusterJ</span>
  clusters.splice(minClusterJ, <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// Print out the result</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cluster <span class="hljs-keyword">of</span> clusters) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> loc <span class="hljs-keyword">of</span> cluster.locs) {
    <span class="hljs-built_in">console</span>.log(loc.properties.name);
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-----'</span>);
}
</code></pre>
<p>As expected, the result shows the algorithm grouped all the North America, Europe, Middle East, and Australia locations together.</p>
<pre><code>$ node cluster-geo.js
New York
Palo Alto
Los Angeles
Austin
-----
Dublin
London
-----
Tel Aviv
-----
Sydney
-----
$
</code></pre><p>Single link clustering has the nice property that you specify ahead of time the number of clusters you want. Depending on your use case, this can be good or bad, because it is prone to creating clusters with objects that are too dissimilar if the desired number of clusters is small. But, if you know the number of clusters you want and don&#39;t really care about outliers, single link is excellent.</p>
<h2 id="clustering-user-behavior">Clustering User Behavior</h2>
<p>The above example isn&#39;t that insightful because you can cluster more easily at a glance than by writing out an algorithm. However, clustering&#39;s usefulness isn&#39;t limited to simple two dimensional cases that you can easily visualize. Recently, I found myself putting together a single link algorithm to cluster users based on the site functionality they use. For example, below is a CSV file <code>access.csv</code> that contains data on users and what endpoints they accessed.</p>
<pre><code>User <span class="hljs-number">1</span>,GET /v2/Driver,<span class="hljs-number">2</span>
User <span class="hljs-number">1</span>,GET /v2/Assignment,<span class="hljs-number">1</span>
User <span class="hljs-number">1</span>,PUT /v2/Assignment,<span class="hljs-number">5</span>
User <span class="hljs-number">1</span>,GET /v2/Region,<span class="hljs-number">1</span>
User <span class="hljs-number">1</span>,GET /v2/Tanker,<span class="hljs-number">2</span>
User <span class="hljs-number">2</span>,GET /v2/Promotion,<span class="hljs-number">7</span>
User <span class="hljs-number">2</span>,GET /v2/Customer,<span class="hljs-number">7</span>
User <span class="hljs-number">2</span>,PUT /v2/Customer,<span class="hljs-number">1</span>
User <span class="hljs-number">2</span>,GET /v2/Region,<span class="hljs-number">5</span>
User <span class="hljs-number">3</span>,GET /v2/Driver,<span class="hljs-number">9</span>
User <span class="hljs-number">3</span>,GET /v2/Assignment,<span class="hljs-number">11</span>
User <span class="hljs-number">3</span>,PUT /v2/Assignment,<span class="hljs-number">120</span>
User <span class="hljs-number">3</span>,GET /v2/Region,<span class="hljs-number">11</span>
User <span class="hljs-number">3</span>,GET /v2/Tanker,<span class="hljs-number">10</span>
User <span class="hljs-number">4</span>,GET /v2/Promotion, <span class="hljs-number">34</span>
User <span class="hljs-number">4</span>,GET /v2/Customer,<span class="hljs-number">22</span>
User <span class="hljs-number">4</span>,GET /v2/Region,<span class="hljs-number">8</span>
</code></pre><p>This data set is small and relatively easy to wrap your head around, but if you had thousands of rows like this, you would have a hard time grouping users manually. For the purposes of this data, the distance metric for clustering will be the minimum between what endpoints are in cluster <code>i</code> but not cluster <code>j</code>, and what endpoints are in cluster <code>j</code> but not cluster <code>i</code>, weighted by the number of times the endpoint was hit. Intuitively, if one user used a subset of the endpoints another user used, they should be considered as part of the same group. This wouldn&#39;t work well if one user was a &quot;super user&quot; that accessed all the endpoints, but in this simple example this distance metric is sufficient to get a sensible result. Below is the implementation.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> userDataCSV = fs.readFileSync(<span class="hljs-string">'./access.csv'</span>, <span class="hljs-string">'utf8'</span>).trim();

<span class="hljs-keyword">const</span> data = userDataCSV.split(<span class="hljs-string">'\n'</span>).map(line =&gt; line.split(<span class="hljs-string">','</span>)).map(cols =&gt; ({
  name: cols[<span class="hljs-number">0</span>],
  url: cols[<span class="hljs-number">1</span>],
  number: <span class="hljs-built_in">parseInt</span>(cols[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>)
}));

<span class="hljs-keyword">const</span> users = data.reduce((cur, obj) =&gt; {
  cur[obj.name] = cur[obj.name] || {};
  cur[obj.name][obj.url] = obj.number;
  <span class="hljs-keyword">return</span> cur;
}, {});

<span class="hljs-keyword">const</span> clusters = <span class="hljs-built_in">Object</span>.keys(users).map(name =&gt; ({
  users: [name],
  totals: <span class="hljs-built_in">Object</span>.assign({}, users[name])
}));

<span class="hljs-keyword">while</span> (clusters.length &gt; <span class="hljs-number">2</span>) {
  <span class="hljs-comment">// Find two closest clusters</span>
  <span class="hljs-keyword">let</span> minClusterDistance = <span class="hljs-built_in">Number</span>.POSITIVE_INFINITY;
  <span class="hljs-keyword">let</span> minClusterI = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">let</span> minClusterJ = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; clusters.length; ++i) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; clusters.length; ++j) {
      <span class="hljs-keyword">const</span> distanceIToJ = <span class="hljs-built_in">Object</span>.keys(clusters[i].totals).reduce((cur, url) =&gt; {
        <span class="hljs-keyword">if</span> (!clusters[j].totals[url]) {
          <span class="hljs-keyword">return</span> cur + clusters[i].totals[url]
        }
        <span class="hljs-keyword">return</span> cur
      }, <span class="hljs-number">0</span>)
      <span class="hljs-keyword">const</span> distanceJToI = <span class="hljs-built_in">Object</span>.keys(clusters[j].totals).reduce((cur, url) =&gt; {
        <span class="hljs-keyword">if</span> (!clusters[i].totals[url]) {
          <span class="hljs-keyword">return</span> cur + clusters[j].totals[url]
        }
        <span class="hljs-keyword">return</span> cur
      }, <span class="hljs-number">0</span>)
      <span class="hljs-keyword">const</span> dist = <span class="hljs-built_in">Math</span>.min(distanceIToJ, distanceJToI);
      <span class="hljs-keyword">if</span> (dist &lt; minClusterDistance) {
        minClusterDistance = dist;
        minClusterI = i;
        minClusterJ = j;
      }
    }
  }

  clusters[minClusterI].users = clusters[minClusterI].users.concat(clusters[minClusterJ].users);
  <span class="hljs-built_in">Object</span>.keys(clusters[minClusterJ].totals).forEach(key =&gt; {
    clusters[minClusterI].totals[key] = clusters[minClusterI].totals[key] || <span class="hljs-number">0</span>;
    clusters[minClusterI].totals[key] += clusters[minClusterJ].totals[key];
  });
  <span class="hljs-comment">// and removing minClusterJ</span>
  clusters.splice(minClusterJ, <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// Print out the result</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cluster <span class="hljs-keyword">of</span> clusters) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> user <span class="hljs-keyword">of</span> cluster.users) {
    <span class="hljs-built_in">console</span>.log(user);
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-----'</span>);
}
</code></pre>
<p>The output clusters users 1 and 3 together, and users 2 and 4 together, as expected.</p>
<pre><code>$ node cluster-users.js
User <span class="hljs-number">1</span>
User <span class="hljs-number">3</span>
-----
User <span class="hljs-number">2</span>
User <span class="hljs-number">4</span>
-----
$
</code></pre><h2 id="moving-on">Moving On</h2>
<p>Clustering is a very useful tool for analyzing data that you don&#39;t understand. Finding groups can help you categorize the data, and categorized data is easier to wrap your head around. The hard part is choosing a distance metric that makes sense: the above distance metric for user data isn&#39;t very robust and is prone to being rendered useless by one outlier. However, even if a distance metric provides you with a bad categorization, it can still provide you valuable insight.</p>
</div><div style="color: #666666; border-top: 1px dashed #666666; margin: 25px; text-align: center; padding-top: 10px"><em>Found a typo or error? Open up a pull request! This post is
available as markdown on&nbsp;<a href="https://github.com/vkarpov15/thecodebarbarian.com/blob/master/lib/posts/20180316_slink.md">Github</a></em></div><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'codebarbarian'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div></div><div style="padding-bottom: 100px">&nbsp;</div><script type="text/javascript">!function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.0.1";
  analytics.load("5DErrxzVhprg8sNh8xaiKDR6dNa7yGTI");
  analytics.page()
}}();</script><script type="text/javascript">analytics.track('opened post',
  { title: "Single Link Clustering with Node.js", time: new Date() });
  </script><script type="text/javascript" src="/js/native.js"></script><link rel="stylesheet" href="/style/inlinecpc.css"/></body></html>